<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - fuzz_coverage.info - src/wallet/coinselection.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

          <table width="100%" border=0 cellspacing=0 cellpadding=0>
            <tr><td class="title">LCOV - code coverage report</td></tr>
            <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

            <tr>
              <td width="100%">
                <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="10%" class="headerValue"><a href="../../index.html" title="Click to go to top-level">top level</a> - <a href="index.html" title="Click to go to directory src/wallet">src/wallet</a> - coinselection.cpp<span style="font-size: 80%;"> (source / <a href="coinselection.cpp.func-c.html" title="Click to go to function table">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="5%"></td>
            <td width="5%" class="headerCovTableHead">Coverage</td>
            <td width="5%" class="headerCovTableHead" title="Covered + Uncovered code">Total</td>
            <td width="5%" class="headerCovTableHead" title="Exercised code only">Hit</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">fuzz_coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntryLo">0.0&nbsp;%</td>
            <td class="headerCovTableEntry">379</td>
            <td class="headerCovTableEntry">0</td>
          </tr>
          <tr>
            <td class="headerItem">Test Date:</td>
            <td class="headerValue">2025-04-03 06:30:20</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntryLo">0.0&nbsp;%</td>
            <td class="headerCovTableEntry">34</td>
            <td class="headerCovTableEntry">0</td>
          </tr>
          <tr>
            <td></td>
            <td></td>
            <td></td>
            <td class="headerItem">Branches:</td>
            <td class="headerCovTableEntryLo">0.0&nbsp;%</td>
            <td class="headerCovTableEntry">436</td>
            <td class="headerCovTableEntry">0</td>
          </tr>
                  <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
                </table>
              </td>
            </tr>

            <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
          </table>

          <table cellpadding=0 cellspacing=0 border=0>
            <tr>
              <td><br></td>
            </tr>
            <tr>
              <td>
<pre class="sourceHeading">             Branch data     Line data    Source code</pre>
<pre class="source">
<span id="L1"><span class="lineNum">       1</span>                 :             : // Copyright (c) 2017-2022 The Bitcoin Core developers</span>
<span id="L2"><span class="lineNum">       2</span>                 :             : // Distributed under the MIT software license, see the accompanying</span>
<span id="L3"><span class="lineNum">       3</span>                 :             : // file COPYING or http://www.opensource.org/licenses/mit-license.php.</span>
<span id="L4"><span class="lineNum">       4</span>                 :             : </span>
<span id="L5"><span class="lineNum">       5</span>                 :             : #include &lt;wallet/coinselection.h&gt;</span>
<span id="L6"><span class="lineNum">       6</span>                 :             : </span>
<span id="L7"><span class="lineNum">       7</span>                 :             : #include &lt;common/system.h&gt;</span>
<span id="L8"><span class="lineNum">       8</span>                 :             : #include &lt;consensus/amount.h&gt;</span>
<span id="L9"><span class="lineNum">       9</span>                 :             : #include &lt;consensus/consensus.h&gt;</span>
<span id="L10"><span class="lineNum">      10</span>                 :             : #include &lt;interfaces/chain.h&gt;</span>
<span id="L11"><span class="lineNum">      11</span>                 :             : #include &lt;logging.h&gt;</span>
<span id="L12"><span class="lineNum">      12</span>                 :             : #include &lt;policy/feerate.h&gt;</span>
<span id="L13"><span class="lineNum">      13</span>                 :             : #include &lt;util/check.h&gt;</span>
<span id="L14"><span class="lineNum">      14</span>                 :             : #include &lt;util/moneystr.h&gt;</span>
<span id="L15"><span class="lineNum">      15</span>                 :             : </span>
<span id="L16"><span class="lineNum">      16</span>                 :             : #include &lt;numeric&gt;</span>
<span id="L17"><span class="lineNum">      17</span>                 :             : #include &lt;optional&gt;</span>
<span id="L18"><span class="lineNum">      18</span>                 :             : #include &lt;queue&gt;</span>
<span id="L19"><span class="lineNum">      19</span>                 :             : </span>
<span id="L20"><span class="lineNum">      20</span>                 :             : namespace wallet {</span>
<span id="L21"><span class="lineNum">      21</span>                 :             : // Common selection error across the algorithms</span>
<span id="L22"><span class="lineNum">      22</span>                 :<span class="tlaUNC">           0 : static util::Result&lt;SelectionResult&gt; ErrorMaxWeightExceeded()</span></span>
<span id="L23"><span class="lineNum">      23</span>                 :             : {</span>
<span id="L24"><span class="lineNum">      24</span>                 :<span class="tlaUNC">           0 :     return util::Error{_(&quot;The inputs size exceeds the maximum weight. &quot;</span></span>
<span id="L25"><span class="lineNum">      25</span>                 :<span class="tlaUNC">           0 :                          &quot;Please try sending a smaller amount or manually consolidating your wallet's UTXOs&quot;)};</span></span>
<span id="L26"><span class="lineNum">      26</span>                 :             : }</span>
<span id="L27"><span class="lineNum">      27</span>                 :             : </span>
<span id="L28"><span class="lineNum">      28</span>                 :             : // Sort by descending (effective) value prefer lower waste on tie</span>
<span id="L29"><span class="lineNum">      29</span>                 :             : struct {</span>
<span id="L30"><span class="lineNum">      30</span>                 :<span class="tlaUNC">           0 :     bool operator()(const OutputGroup&amp; a, const OutputGroup&amp; b) const</span></span>
<span id="L31"><span class="lineNum">      31</span>                 :             :     {</span>
<span id="L32"><span class="lineNum">      32</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (a.GetSelectionAmount() == b.GetSelectionAmount()) {</span></span>
<span id="L33"><span class="lineNum">      33</span>                 :             :             // Lower waste is better when effective_values are tied</span>
<span id="L34"><span class="lineNum">      34</span>                 :<span class="tlaUNC">           0 :             return (a.fee - a.long_term_fee) &lt; (b.fee - b.long_term_fee);</span></span>
<span id="L35"><span class="lineNum">      35</span>                 :             :         }</span>
<span id="L36"><span class="lineNum">      36</span>                 :<span class="tlaUNC">           0 :         return a.GetSelectionAmount() &gt; b.GetSelectionAmount();</span></span>
<span id="L37"><span class="lineNum">      37</span>                 :             :     }</span>
<span id="L38"><span class="lineNum">      38</span>                 :             : } descending;</span>
<span id="L39"><span class="lineNum">      39</span>                 :             : </span>
<span id="L40"><span class="lineNum">      40</span>                 :             : // Sort by descending (effective) value prefer lower weight on tie</span>
<span id="L41"><span class="lineNum">      41</span>                 :             : struct {</span>
<span id="L42"><span class="lineNum">      42</span>                 :<span class="tlaUNC">           0 :     bool operator()(const OutputGroup&amp; a, const OutputGroup&amp; b) const</span></span>
<span id="L43"><span class="lineNum">      43</span>                 :             :     {</span>
<span id="L44"><span class="lineNum">      44</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (a.GetSelectionAmount() == b.GetSelectionAmount()) {</span></span>
<span id="L45"><span class="lineNum">      45</span>                 :             :             // Sort lower weight to front on tied effective_value</span>
<span id="L46"><span class="lineNum">      46</span>                 :<span class="tlaUNC">           0 :             return a.m_weight &lt; b.m_weight;</span></span>
<span id="L47"><span class="lineNum">      47</span>                 :             :         }</span>
<span id="L48"><span class="lineNum">      48</span>                 :<span class="tlaUNC">           0 :         return a.GetSelectionAmount() &gt; b.GetSelectionAmount();</span></span>
<span id="L49"><span class="lineNum">      49</span>                 :             :     }</span>
<span id="L50"><span class="lineNum">      50</span>                 :             : } descending_effval_weight;</span>
<span id="L51"><span class="lineNum">      51</span>                 :             : </span>
<span id="L52"><span class="lineNum">      52</span>                 :             : /*</span>
<span id="L53"><span class="lineNum">      53</span>                 :             :  * This is the Branch and Bound Coin Selection algorithm designed by Murch. It searches for an input</span>
<span id="L54"><span class="lineNum">      54</span>                 :             :  * set that can pay for the spending target and does not exceed the spending target by more than the</span>
<span id="L55"><span class="lineNum">      55</span>                 :             :  * cost of creating and spending a change output. The algorithm uses a depth-first search on a binary</span>
<span id="L56"><span class="lineNum">      56</span>                 :             :  * tree. In the binary tree, each node corresponds to the inclusion or the omission of a UTXO. UTXOs</span>
<span id="L57"><span class="lineNum">      57</span>                 :             :  * are sorted by their effective values and the tree is explored deterministically per the inclusion</span>
<span id="L58"><span class="lineNum">      58</span>                 :             :  * branch first. At each node, the algorithm checks whether the selection is within the target range.</span>
<span id="L59"><span class="lineNum">      59</span>                 :             :  * While the selection has not reached the target range, more UTXOs are included. When a selection's</span>
<span id="L60"><span class="lineNum">      60</span>                 :             :  * value exceeds the target range, the complete subtree deriving from this selection can be omitted.</span>
<span id="L61"><span class="lineNum">      61</span>                 :             :  * At that point, the last included UTXO is deselected and the corresponding omission branch explored</span>
<span id="L62"><span class="lineNum">      62</span>                 :             :  * instead. The search ends after the complete tree has been searched or after a limited number of tries.</span>
<span id="L63"><span class="lineNum">      63</span>                 :             :  *</span>
<span id="L64"><span class="lineNum">      64</span>                 :             :  * The search continues to search for better solutions after one solution has been found. The best</span>
<span id="L65"><span class="lineNum">      65</span>                 :             :  * solution is chosen by minimizing the waste metric. The waste metric is defined as the cost to</span>
<span id="L66"><span class="lineNum">      66</span>                 :             :  * spend the current inputs at the given fee rate minus the long term expected cost to spend the</span>
<span id="L67"><span class="lineNum">      67</span>                 :             :  * inputs, plus the amount by which the selection exceeds the spending target:</span>
<span id="L68"><span class="lineNum">      68</span>                 :             :  *</span>
<span id="L69"><span class="lineNum">      69</span>                 :             :  * waste = selectionTotal - target + inputs × (currentFeeRate - longTermFeeRate)</span>
<span id="L70"><span class="lineNum">      70</span>                 :             :  *</span>
<span id="L71"><span class="lineNum">      71</span>                 :             :  * The algorithm uses two additional optimizations. A lookahead keeps track of the total value of</span>
<span id="L72"><span class="lineNum">      72</span>                 :             :  * the unexplored UTXOs. A subtree is not explored if the lookahead indicates that the target range</span>
<span id="L73"><span class="lineNum">      73</span>                 :             :  * cannot be reached. Further, it is unnecessary to test equivalent combinations. This allows us</span>
<span id="L74"><span class="lineNum">      74</span>                 :             :  * to skip testing the inclusion of UTXOs that match the effective value and waste of an omitted</span>
<span id="L75"><span class="lineNum">      75</span>                 :             :  * predecessor.</span>
<span id="L76"><span class="lineNum">      76</span>                 :             :  *</span>
<span id="L77"><span class="lineNum">      77</span>                 :             :  * The Branch and Bound algorithm is described in detail in Murch's Master Thesis:</span>
<span id="L78"><span class="lineNum">      78</span>                 :             :  * https://murch.one/wp-content/uploads/2016/11/erhardt2016coinselection.pdf</span>
<span id="L79"><span class="lineNum">      79</span>                 :             :  *</span>
<span id="L80"><span class="lineNum">      80</span>                 :             :  * @param const std::vector&lt;OutputGroup&gt;&amp; utxo_pool The set of UTXO groups that we are choosing from.</span>
<span id="L81"><span class="lineNum">      81</span>                 :             :  *        These UTXO groups will be sorted in descending order by effective value and the OutputGroups'</span>
<span id="L82"><span class="lineNum">      82</span>                 :             :  *        values are their effective values.</span>
<span id="L83"><span class="lineNum">      83</span>                 :             :  * @param const CAmount&amp; selection_target This is the value that we want to select. It is the lower</span>
<span id="L84"><span class="lineNum">      84</span>                 :             :  *        bound of the range.</span>
<span id="L85"><span class="lineNum">      85</span>                 :             :  * @param const CAmount&amp; cost_of_change This is the cost of creating and spending a change output.</span>
<span id="L86"><span class="lineNum">      86</span>                 :             :  *        This plus selection_target is the upper bound of the range.</span>
<span id="L87"><span class="lineNum">      87</span>                 :             :  * @param int max_selection_weight The maximum allowed weight for a selection result to be valid.</span>
<span id="L88"><span class="lineNum">      88</span>                 :             :  * @returns The result of this coin selection algorithm, or std::nullopt</span>
<span id="L89"><span class="lineNum">      89</span>                 :             :  */</span>
<span id="L90"><span class="lineNum">      90</span>                 :             : </span>
<span id="L91"><span class="lineNum">      91</span>                 :             : static const size_t TOTAL_TRIES = 100000;</span>
<span id="L92"><span class="lineNum">      92</span>                 :             : </span>
<span id="L93"><span class="lineNum">      93</span>                 :<span class="tlaUNC">           0 : util::Result&lt;SelectionResult&gt; SelectCoinsBnB(std::vector&lt;OutputGroup&gt;&amp; utxo_pool, const CAmount&amp; selection_target, const CAmount&amp; cost_of_change,</span></span>
<span id="L94"><span class="lineNum">      94</span>                 :             :                                              int max_selection_weight)</span>
<span id="L95"><span class="lineNum">      95</span>                 :             : {</span>
<span id="L96"><span class="lineNum">      96</span>                 :<span class="tlaUNC">           0 :     SelectionResult result(selection_target, SelectionAlgorithm::BNB);</span></span>
<span id="L97"><span class="lineNum">      97</span>                 :<span class="tlaUNC">           0 :     CAmount curr_value = 0;</span></span>
<span id="L98"><span class="lineNum">      98</span>                 :<span class="tlaUNC">           0 :     std::vector&lt;size_t&gt; curr_selection; // selected utxo indexes</span></span>
<span id="L99"><span class="lineNum">      99</span>                 :<span class="tlaUNC">           0 :     int curr_selection_weight = 0; // sum of selected utxo weight</span></span>
<span id="L100"><span class="lineNum">     100</span>                 :             : </span>
<span id="L101"><span class="lineNum">     101</span>                 :             :     // Calculate curr_available_value</span>
<span id="L102"><span class="lineNum">     102</span>                 :<span class="tlaUNC">           0 :     CAmount curr_available_value = 0;</span></span>
<span id="L103"><span class="lineNum">     103</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     for (const OutputGroup&amp; utxo : utxo_pool) {</span></span>
<span id="L104"><span class="lineNum">     104</span>                 :             :         // Assert that this utxo is not negative. It should never be negative,</span>
<span id="L105"><span class="lineNum">     105</span>                 :             :         // effective value calculation should have removed it</span>
<span id="L106"><span class="lineNum">     106</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         assert(utxo.GetSelectionAmount() &gt; 0);</span></span>
<span id="L107"><span class="lineNum">     107</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         curr_available_value += utxo.GetSelectionAmount();</span></span>
<span id="L108"><span class="lineNum">     108</span>                 :             :     }</span>
<span id="L109"><span class="lineNum">     109</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (curr_available_value &lt; selection_target) {</span></span>
<span id="L110"><span class="lineNum">     110</span>                 :<span class="tlaUNC">           0 :         return util::Error();</span></span>
<span id="L111"><span class="lineNum">     111</span>                 :             :     }</span>
<span id="L112"><span class="lineNum">     112</span>                 :             : </span>
<span id="L113"><span class="lineNum">     113</span>                 :             :     // Sort the utxo_pool</span>
<span id="L114"><span class="lineNum">     114</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     std::sort(utxo_pool.begin(), utxo_pool.end(), descending);</span></span>
<span id="L115"><span class="lineNum">     115</span>                 :             : </span>
<span id="L116"><span class="lineNum">     116</span>                 :<span class="tlaUNC">           0 :     CAmount curr_waste = 0;</span></span>
<span id="L117"><span class="lineNum">     117</span>                 :<span class="tlaUNC">           0 :     std::vector&lt;size_t&gt; best_selection;</span></span>
<span id="L118"><span class="lineNum">     118</span>                 :<span class="tlaUNC">           0 :     CAmount best_waste = MAX_MONEY;</span></span>
<span id="L119"><span class="lineNum">     119</span>                 :             : </span>
<span id="L120"><span class="lineNum">     120</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     bool is_feerate_high = utxo_pool.at(0).fee &gt; utxo_pool.at(0).long_term_fee;</span></span>
<span id="L121"><span class="lineNum">     121</span>                 :<span class="tlaUNC">           0 :     bool max_tx_weight_exceeded = false;</span></span>
<span id="L122"><span class="lineNum">     122</span>                 :             : </span>
<span id="L123"><span class="lineNum">     123</span>                 :             :     // Depth First search loop for choosing the UTXOs</span>
<span id="L124"><span class="lineNum">     124</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     for (size_t curr_try = 0, utxo_pool_index = 0; curr_try &lt; TOTAL_TRIES; ++curr_try, ++utxo_pool_index) {</span></span>
<span id="L125"><span class="lineNum">     125</span>                 :             :         // Conditions for starting a backtrack</span>
<span id="L126"><span class="lineNum">     126</span>                 :<span class="tlaUNC">           0 :         bool backtrack = false;</span></span>
<span id="L127"><span class="lineNum">     127</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (curr_value + curr_available_value &lt; selection_target || // Cannot possibly reach target with the amount remaining in the curr_available_value.</span></span>
<span id="L128"><span class="lineNum">     128</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             curr_value &gt; selection_target + cost_of_change || // Selected value is out of range, go back and try other branch</span></span>
<span id="L129"><span class="lineNum">     129</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             (curr_waste &gt; best_waste &amp;&amp; is_feerate_high)) { // Don't select things which we know will be more wasteful if the waste is increasing</span></span>
<span id="L130"><span class="lineNum">     130</span>                 :             :             backtrack = true;</span>
<span id="L131"><span class="lineNum">     131</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         } else if (curr_selection_weight &gt; max_selection_weight) { // Selected UTXOs weight exceeds the maximum weight allowed, cannot find more solutions by adding more inputs</span></span>
<span id="L132"><span class="lineNum">     132</span>                 :             :             max_tx_weight_exceeded = true; // at least one selection attempt exceeded the max weight</span>
<span id="L133"><span class="lineNum">     133</span>                 :             :             backtrack = true;</span>
<span id="L134"><span class="lineNum">     134</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         } else if (curr_value &gt;= selection_target) {       // Selected value is within range</span></span>
<span id="L135"><span class="lineNum">     135</span>                 :<span class="tlaUNC">           0 :             curr_waste += (curr_value - selection_target); // This is the excess value which is added to the waste for the below comparison</span></span>
<span id="L136"><span class="lineNum">     136</span>                 :             :             // Adding another UTXO after this check could bring the waste down if the long term fee is higher than the current fee.</span>
<span id="L137"><span class="lineNum">     137</span>                 :             :             // However we are not going to explore that because this optimization for the waste is only done when we have hit our target</span>
<span id="L138"><span class="lineNum">     138</span>                 :             :             // value. Adding any more UTXOs will be just burning the UTXO; it will go entirely to fees. Thus we aren't going to</span>
<span id="L139"><span class="lineNum">     139</span>                 :             :             // explore any more UTXOs to avoid burning money like that.</span>
<span id="L140"><span class="lineNum">     140</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (curr_waste &lt;= best_waste) {</span></span>
<span id="L141"><span class="lineNum">     141</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 best_selection = curr_selection;</span></span>
<span id="L142"><span class="lineNum">     142</span>                 :             :                 best_waste = curr_waste;</span>
<span id="L143"><span class="lineNum">     143</span>                 :             :             }</span>
<span id="L144"><span class="lineNum">     144</span>                 :<span class="tlaUNC">           0 :             curr_waste -= (curr_value - selection_target); // Remove the excess value as we will be selecting different coins now</span></span>
<span id="L145"><span class="lineNum">     145</span>                 :<span class="tlaUNC">           0 :             backtrack = true;</span></span>
<span id="L146"><span class="lineNum">     146</span>                 :             :         }</span>
<span id="L147"><span class="lineNum">     147</span>                 :             : </span>
<span id="L148"><span class="lineNum">     148</span>                 :<span class="tlaUNC">           0 :         if (backtrack) { // Backtracking, moving backwards</span></span>
<span id="L149"><span class="lineNum">     149</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (curr_selection.empty()) { // We have walked back to the first utxo and no branch is untraversed. All solutions searched</span></span>
<span id="L150"><span class="lineNum">     150</span>                 :             :                 break;</span>
<span id="L151"><span class="lineNum">     151</span>                 :             :             }</span>
<span id="L152"><span class="lineNum">     152</span>                 :             : </span>
<span id="L153"><span class="lineNum">     153</span>                 :             :             // Add omitted UTXOs back to lookahead before traversing the omission branch of last included UTXO.</span>
<span id="L154"><span class="lineNum">     154</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             for (--utxo_pool_index; utxo_pool_index &gt; curr_selection.back(); --utxo_pool_index) {</span></span>
<span id="L155"><span class="lineNum">     155</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 curr_available_value += utxo_pool.at(utxo_pool_index).GetSelectionAmount();</span></span>
<span id="L156"><span class="lineNum">     156</span>                 :             :             }</span>
<span id="L157"><span class="lineNum">     157</span>                 :             : </span>
<span id="L158"><span class="lineNum">     158</span>                 :             :             // Output was included on previous iterations, try excluding now.</span>
<span id="L159"><span class="lineNum">     159</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             assert(utxo_pool_index == curr_selection.back());</span></span>
<span id="L160"><span class="lineNum">     160</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             OutputGroup&amp; utxo = utxo_pool.at(utxo_pool_index);</span></span>
<span id="L161"><span class="lineNum">     161</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             curr_value -= utxo.GetSelectionAmount();</span></span>
<span id="L162"><span class="lineNum">     162</span>                 :<span class="tlaUNC">           0 :             curr_waste -= utxo.fee - utxo.long_term_fee;</span></span>
<span id="L163"><span class="lineNum">     163</span>                 :<span class="tlaUNC">           0 :             curr_selection_weight -= utxo.m_weight;</span></span>
<span id="L164"><span class="lineNum">     164</span>                 :<span class="tlaUNC">           0 :             curr_selection.pop_back();</span></span>
<span id="L165"><span class="lineNum">     165</span>                 :             :         } else { // Moving forwards, continuing down this branch</span>
<span id="L166"><span class="lineNum">     166</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             OutputGroup&amp; utxo = utxo_pool.at(utxo_pool_index);</span></span>
<span id="L167"><span class="lineNum">     167</span>                 :             : </span>
<span id="L168"><span class="lineNum">     168</span>                 :             :             // Remove this utxo from the curr_available_value utxo amount</span>
<span id="L169"><span class="lineNum">     169</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             curr_available_value -= utxo.GetSelectionAmount();</span></span>
<span id="L170"><span class="lineNum">     170</span>                 :             : </span>
<span id="L171"><span class="lineNum">     171</span>                 :<span class="tlaUNC">           0 :             if (curr_selection.empty() ||</span></span>
<span id="L172"><span class="lineNum">     172</span>                 :             :                 // The previous index is included and therefore not relevant for exclusion shortcut</span>
<span id="L173"><span class="lineNum">     173</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 (utxo_pool_index - 1) == curr_selection.back() ||</span></span>
<span id="L174"><span class="lineNum">     174</span>                 :             :                 // Avoid searching a branch if the previous UTXO has the same value and same waste and was excluded.</span>
<span id="L175"><span class="lineNum">     175</span>                 :             :                 // Since the ratio of fee to long term fee is the same, we only need to check if one of those values match in order to know that the waste is the same.</span>
<span id="L176"><span class="lineNum">     176</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :                 utxo.GetSelectionAmount() != utxo_pool.at(utxo_pool_index - 1).GetSelectionAmount() ||</span></span>
<span class="lineNum">        </span>    <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span><span class="tlaUNC" title="Branch 6 was not executed"> # </span><span class="tlaUNC" title="Branch 7 was not executed"> # </span>]
<span id="L177"><span class="lineNum">     177</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 utxo.fee != utxo_pool.at(utxo_pool_index - 1).fee)</span></span>
<span id="L178"><span class="lineNum">     178</span>                 :             :             {</span>
<span id="L179"><span class="lineNum">     179</span>                 :             :                 // Inclusion branch first (Largest First Exploration)</span>
<span id="L180"><span class="lineNum">     180</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 curr_selection.push_back(utxo_pool_index);</span></span>
<span id="L181"><span class="lineNum">     181</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 curr_value += utxo.GetSelectionAmount();</span></span>
<span id="L182"><span class="lineNum">     182</span>                 :<span class="tlaUNC">           0 :                 curr_waste += utxo.fee - utxo.long_term_fee;</span></span>
<span id="L183"><span class="lineNum">     183</span>                 :<span class="tlaUNC">           0 :                 curr_selection_weight += utxo.m_weight;</span></span>
<span id="L184"><span class="lineNum">     184</span>                 :             :             }</span>
<span id="L185"><span class="lineNum">     185</span>                 :             :         }</span>
<span id="L186"><span class="lineNum">     186</span>                 :             :     }</span>
<span id="L187"><span class="lineNum">     187</span>                 :             : </span>
<span id="L188"><span class="lineNum">     188</span>                 :             :     // Check for solution</span>
<span id="L189"><span class="lineNum">     189</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (best_selection.empty()) {</span></span>
<span id="L190"><span class="lineNum">     190</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         return max_tx_weight_exceeded ? ErrorMaxWeightExceeded() : util::Error();</span></span>
<span id="L191"><span class="lineNum">     191</span>                 :             :     }</span>
<span id="L192"><span class="lineNum">     192</span>                 :             : </span>
<span id="L193"><span class="lineNum">     193</span>                 :             :     // Set output set</span>
<span id="L194"><span class="lineNum">     194</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     for (const size_t&amp; i : best_selection) {</span></span>
<span id="L195"><span class="lineNum">     195</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         result.AddInput(utxo_pool.at(i));</span></span>
<span id="L196"><span class="lineNum">     196</span>                 :             :     }</span>
<span id="L197"><span class="lineNum">     197</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     result.RecalculateWaste(cost_of_change, cost_of_change, CAmount{0});</span></span>
<span id="L198"><span class="lineNum">     198</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     assert(best_waste == result.GetWaste());</span></span>
<span id="L199"><span class="lineNum">     199</span>                 :             : </span>
<span id="L200"><span class="lineNum">     200</span>                 :<span class="tlaUNC">           0 :     return result;</span></span>
<span id="L201"><span class="lineNum">     201</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L202"><span class="lineNum">     202</span>                 :             : </span>
<span id="L203"><span class="lineNum">     203</span>                 :             : /*</span>
<span id="L204"><span class="lineNum">     204</span>                 :             :  * TL;DR: Coin Grinder is a DFS-based algorithm that deterministically searches for the minimum-weight input set to fund</span>
<span id="L205"><span class="lineNum">     205</span>                 :             :  * the transaction. The algorithm is similar to the Branch and Bound algorithm, but will produce a transaction _with_ a</span>
<span id="L206"><span class="lineNum">     206</span>                 :             :  * change output instead of a changeless transaction.</span>
<span id="L207"><span class="lineNum">     207</span>                 :             :  *</span>
<span id="L208"><span class="lineNum">     208</span>                 :             :  * Full description: CoinGrinder can be thought of as a graph walking algorithm. It explores a binary tree</span>
<span id="L209"><span class="lineNum">     209</span>                 :             :  * representation of the powerset of the UTXO pool. Each node in the tree represents a candidate input set. The tree’s</span>
<span id="L210"><span class="lineNum">     210</span>                 :             :  * root is the empty set. Each node in the tree has two children which are formed by either adding or skipping the next</span>
<span id="L211"><span class="lineNum">     211</span>                 :             :  * UTXO (&quot;inclusion/omission branch&quot;). Each level in the tree after the root corresponds to a decision about one UTXO in</span>
<span id="L212"><span class="lineNum">     212</span>                 :             :  * the UTXO pool.</span>
<span id="L213"><span class="lineNum">     213</span>                 :             :  *</span>
<span id="L214"><span class="lineNum">     214</span>                 :             :  * Example:</span>
<span id="L215"><span class="lineNum">     215</span>                 :             :  * We represent UTXOs as _alias=[effective_value/weight]_ and indicate omitted UTXOs with an underscore. Given a UTXO</span>
<span id="L216"><span class="lineNum">     216</span>                 :             :  * pool {A=[10/2], B=[7/1], C=[5/1], D=[4/2]} sorted by descending effective value, our search tree looks as follows:</span>
<span id="L217"><span class="lineNum">     217</span>                 :             :  *</span>
<span id="L218"><span class="lineNum">     218</span>                 :             :  *                                       _______________________ {} ________________________</span>
<span id="L219"><span class="lineNum">     219</span>                 :             :  *                                      /                                                   \</span>
<span id="L220"><span class="lineNum">     220</span>                 :             :  * A=[10/2]               __________ {A} _________                                __________ {_} _________</span>
<span id="L221"><span class="lineNum">     221</span>                 :             :  *                       /                        \                              /                        \</span>
<span id="L222"><span class="lineNum">     222</span>                 :             :  * B=[7/1]            {AB} _                      {A_} _                      {_B} _                      {__} _</span>
<span id="L223"><span class="lineNum">     223</span>                 :             :  *                  /       \                   /       \                   /       \                   /       \</span>
<span id="L224"><span class="lineNum">     224</span>                 :             :  * C=[5/1]     {ABC}         {AB_}         {A_C}         {A__}         {_BC}         {_B_}         {__C}         {___}</span>
<span id="L225"><span class="lineNum">     225</span>                 :             :  *              / \           / \           / \           / \           / \           / \           / \           / \</span>
<span id="L226"><span class="lineNum">     226</span>                 :             :  * D=[4/2] {ABCD} {ABC_} {AB_D} {AB__} {A_CD} {A_C_} {A__D} {A___} {_BCD} {_BC_} {_B_D} {_B__} {__CD} {__C_} {___D} {____}</span>
<span id="L227"><span class="lineNum">     227</span>                 :             :  *</span>
<span id="L228"><span class="lineNum">     228</span>                 :             :  *</span>
<span id="L229"><span class="lineNum">     229</span>                 :             :  * CoinGrinder uses a depth-first search to walk this tree. It first tries inclusion branches, then omission branches. A</span>
<span id="L230"><span class="lineNum">     230</span>                 :             :  * naive exploration of a tree with four UTXOs requires visiting all 31 nodes:</span>
<span id="L231"><span class="lineNum">     231</span>                 :             :  *</span>
<span id="L232"><span class="lineNum">     232</span>                 :             :  *     {} {A} {AB} {ABC} {ABCD} {ABC_} {AB_} {AB_D} {AB__} {A_} {A_C} {A_CD} {A_C_} {A__} {A__D} {A___} {_} {_B} {_BC}</span>
<span id="L233"><span class="lineNum">     233</span>                 :             :  *     {_BCD} {_BC_} {_B_} {_B_D} {_B__} {__} {__C} {__CD} {__C} {___} {___D} {____}</span>
<span id="L234"><span class="lineNum">     234</span>                 :             :  *</span>
<span id="L235"><span class="lineNum">     235</span>                 :             :  * As powersets grow exponentially with the set size, walking the entire tree would quickly get computationally</span>
<span id="L236"><span class="lineNum">     236</span>                 :             :  * infeasible with growing UTXO pools. Thanks to traversing the tree in a deterministic order, we can keep track of the</span>
<span id="L237"><span class="lineNum">     237</span>                 :             :  * progress of the search solely on basis of the current selection (and the best selection so far). We visit as few</span>
<span id="L238"><span class="lineNum">     238</span>                 :             :  * nodes as possible by recognizing and skipping any branches that can only contain solutions worse than the best</span>
<span id="L239"><span class="lineNum">     239</span>                 :             :  * solution so far. This makes CoinGrinder a branch-and-bound algorithm</span>
<span id="L240"><span class="lineNum">     240</span>                 :             :  * (https://en.wikipedia.org/wiki/Branch_and_bound).</span>
<span id="L241"><span class="lineNum">     241</span>                 :             :  * CoinGrinder is searching for the input set with lowest weight that can fund a transaction, so for example we can only</span>
<span id="L242"><span class="lineNum">     242</span>                 :             :  * ever find a _better_ candidate input set in a node that adds a UTXO, but never in a node that skips a UTXO. After</span>
<span id="L243"><span class="lineNum">     243</span>                 :             :  * visiting {A} and exploring the inclusion branch {AB} and its descendants, the candidate input set in the omission</span>
<span id="L244"><span class="lineNum">     244</span>                 :             :  * branch {A_} is equivalent to the parent {A} in effective value and weight. While CoinGrinder does need to visit the</span>
<span id="L245"><span class="lineNum">     245</span>                 :             :  * descendants of the omission branch {A_}, it is unnecessary to evaluate the candidate input set in the omission branch</span>
<span id="L246"><span class="lineNum">     246</span>                 :             :  * itself. By skipping evaluation of all nodes on an omission branch we reduce the visited nodes to 15:</span>
<span id="L247"><span class="lineNum">     247</span>                 :             :  *</span>
<span id="L248"><span class="lineNum">     248</span>                 :             :  *     {A} {AB} {ABC} {ABCD} {AB_D} {A_C} {A_CD} {A__D} {_B} {_BC} {_BCD} {_B_D} {__C} {__CD} {___D}</span>
<span id="L249"><span class="lineNum">     249</span>                 :             :  *</span>
<span id="L250"><span class="lineNum">     250</span>                 :             :  *                                       _______________________ {} ________________________</span>
<span id="L251"><span class="lineNum">     251</span>                 :             :  *                                      /                                                   \</span>
<span id="L252"><span class="lineNum">     252</span>                 :             :  * A=[10/2]               __________ {A} _________                                ___________\____________</span>
<span id="L253"><span class="lineNum">     253</span>                 :             :  *                       /                        \                              /                        \</span>
<span id="L254"><span class="lineNum">     254</span>                 :             :  * B=[7/1]            {AB} __                    __\_____                     {_B} __                    __\_____</span>
<span id="L255"><span class="lineNum">     255</span>                 :             :  *                  /        \                  /        \                  /        \                  /        \</span>
<span id="L256"><span class="lineNum">     256</span>                 :             :  * C=[5/1]     {ABC}          \            {A_C}          \            {_BC}          \            {__C}          \</span>
<span id="L257"><span class="lineNum">     257</span>                 :             :  *              /             /             /             /             /             /             /             /</span>
<span id="L258"><span class="lineNum">     258</span>                 :             :  * D=[4/2] {ABCD}        {AB_D}        {A_CD}        {A__D}        {_BCD}        {_B_D}        {__CD}        {___D}</span>
<span id="L259"><span class="lineNum">     259</span>                 :             :  *</span>
<span id="L260"><span class="lineNum">     260</span>                 :             :  *</span>
<span id="L261"><span class="lineNum">     261</span>                 :             :  * We refer to the move from the inclusion branch {AB} via the omission branch {A_} to its inclusion-branch child {A_C}</span>
<span id="L262"><span class="lineNum">     262</span>                 :             :  * as _shifting to the omission branch_ or just _SHIFT_. (The index of the ultimate element in the candidate input set</span>
<span id="L263"><span class="lineNum">     263</span>                 :             :  * shifts right by one: {AB} ⇒ {A_C}.)</span>
<span id="L264"><span class="lineNum">     264</span>                 :             :  * When we reach a leaf node in the last level of the tree, shifting to the omission branch is not possible. Instead we</span>
<span id="L265"><span class="lineNum">     265</span>                 :             :  * go to the omission branch of the node’s last ancestor on an inclusion branch: from {ABCD}, we go to {AB_D}. From</span>
<span id="L266"><span class="lineNum">     266</span>                 :             :  * {AB_D}, we go to {A_C}. We refer to this operation as a _CUT_. (The ultimate element in</span>
<span id="L267"><span class="lineNum">     267</span>                 :             :  * the input set is deselected, and the penultimate element is shifted right by one: {AB_D} ⇒ {A_C}.)</span>
<span id="L268"><span class="lineNum">     268</span>                 :             :  * If a candidate input set in a node has not selected sufficient funds to build the transaction, we continue directly</span>
<span id="L269"><span class="lineNum">     269</span>                 :             :  * along the next inclusion branch. We call this operation _EXPLORE_. (We go from one inclusion branch to the next</span>
<span id="L270"><span class="lineNum">     270</span>                 :             :  * inclusion branch: {_B} ⇒ {_BC}.)</span>
<span id="L271"><span class="lineNum">     271</span>                 :             :  * Further, any prefix that already has selected sufficient effective value to fund the transaction cannot be improved</span>
<span id="L272"><span class="lineNum">     272</span>                 :             :  * by adding more UTXOs. If for example the candidate input set in {AB} is a valid solution, all potential descendant</span>
<span id="L273"><span class="lineNum">     273</span>                 :             :  * solutions {ABC}, {ABCD}, and {AB_D} must have a higher weight, thus instead of exploring the descendants of {AB}, we</span>
<span id="L274"><span class="lineNum">     274</span>                 :             :  * can SHIFT from {AB} to {A_C}.</span>
<span id="L275"><span class="lineNum">     275</span>                 :             :  *</span>
<span id="L276"><span class="lineNum">     276</span>                 :             :  * Given the above UTXO set, using a target of 11, and following these initial observations, the basic implementation of</span>
<span id="L277"><span class="lineNum">     277</span>                 :             :  * CoinGrinder visits the following 10 nodes:</span>
<span id="L278"><span class="lineNum">     278</span>                 :             :  *</span>
<span id="L279"><span class="lineNum">     279</span>                 :             :  *     Node   [eff_val/weight]  Evaluation</span>
<span id="L280"><span class="lineNum">     280</span>                 :             :  *     ---------------------------------------------------------------</span>
<span id="L281"><span class="lineNum">     281</span>                 :             :  *     {A}    [10/2]            Insufficient funds: EXPLORE</span>
<span id="L282"><span class="lineNum">     282</span>                 :             :  *     {AB}   [17/3]            Solution: SHIFT to omission branch</span>
<span id="L283"><span class="lineNum">     283</span>                 :             :  *     {A_C}  [15/3]            Better solution: SHIFT to omission branch</span>
<span id="L284"><span class="lineNum">     284</span>                 :             :  *     {A__D} [14/4]            Worse solution, shift impossible due to leaf node: CUT to omission branch of {A__D},</span>
<span id="L285"><span class="lineNum">     285</span>                 :             :  *                              i.e. SHIFT to omission branch of {A}</span>
<span id="L286"><span class="lineNum">     286</span>                 :             :  *     {_B}   [7/1]             Insufficient funds: EXPLORE</span>
<span id="L287"><span class="lineNum">     287</span>                 :             :  *     {_BC}  [12/2]            Better solution: SHIFT to omission branch</span>
<span id="L288"><span class="lineNum">     288</span>                 :             :  *     {_B_D} [11/3]            Worse solution, shift impossible due to leaf node: CUT to omission branch of {_B_D},</span>
<span id="L289"><span class="lineNum">     289</span>                 :             :  *                              i.e. SHIFT to omission branch of {_B}</span>
<span id="L290"><span class="lineNum">     290</span>                 :             :  *     {__C}  [5/1]             Insufficient funds: EXPLORE</span>
<span id="L291"><span class="lineNum">     291</span>                 :             :  *     {__CD} [9/3]             Insufficient funds, leaf node: CUT</span>
<span id="L292"><span class="lineNum">     292</span>                 :             :  *     {___D} [4/2]             Insufficient funds, leaf node, cannot CUT since only one UTXO selected: done.</span>
<span id="L293"><span class="lineNum">     293</span>                 :             :  *</span>
<span id="L294"><span class="lineNum">     294</span>                 :             :  *                                       _______________________ {} ________________________</span>
<span id="L295"><span class="lineNum">     295</span>                 :             :  *                                      /                                                   \</span>
<span id="L296"><span class="lineNum">     296</span>                 :             :  * A=[10/2]               __________ {A} _________                                ___________\____________</span>
<span id="L297"><span class="lineNum">     297</span>                 :             :  *                       /                        \                              /                        \</span>
<span id="L298"><span class="lineNum">     298</span>                 :             :  * B=[7/1]            {AB}                       __\_____                     {_B} __                    __\_____</span>
<span id="L299"><span class="lineNum">     299</span>                 :             :  *                                              /        \                  /        \                  /        \</span>
<span id="L300"><span class="lineNum">     300</span>                 :             :  * C=[5/1]                                 {A_C}          \            {_BC}          \            {__C}          \</span>
<span id="L301"><span class="lineNum">     301</span>                 :             :  *                                                        /                           /             /             /</span>
<span id="L302"><span class="lineNum">     302</span>                 :             :  * D=[4/2]                                           {A__D}                      {_B_D}        {__CD}        {___D}</span>
<span id="L303"><span class="lineNum">     303</span>                 :             :  *</span>
<span id="L304"><span class="lineNum">     304</span>                 :             :  *</span>
<span id="L305"><span class="lineNum">     305</span>                 :             :  * We implement this tree walk in the following algorithm:</span>
<span id="L306"><span class="lineNum">     306</span>                 :             :  * 1. Add `next_utxo`</span>
<span id="L307"><span class="lineNum">     307</span>                 :             :  * 2. Evaluate candidate input set</span>
<span id="L308"><span class="lineNum">     308</span>                 :             :  * 3. Determine `next_utxo` by deciding whether to</span>
<span id="L309"><span class="lineNum">     309</span>                 :             :  *    a) EXPLORE: Add next inclusion branch, e.g. {_B} ⇒ {_B} + `next_uxto`: C</span>
<span id="L310"><span class="lineNum">     310</span>                 :             :  *    b) SHIFT: Replace last selected UTXO by next higher index, e.g. {A_C} ⇒ {A__} + `next_utxo`: D</span>
<span id="L311"><span class="lineNum">     311</span>                 :             :  *    c) CUT: deselect last selected UTXO and shift to omission branch of penultimate UTXO, e.g. {AB_D} ⇒ {A_} + `next_utxo: C</span>
<span id="L312"><span class="lineNum">     312</span>                 :             :  *</span>
<span id="L313"><span class="lineNum">     313</span>                 :             :  * The implementation then adds further optimizations by discovering further situations in which either the inclusion</span>
<span id="L314"><span class="lineNum">     314</span>                 :             :  * branch can be skipped, or both the inclusion and omission branch can be skipped after evaluating the candidate input</span>
<span id="L315"><span class="lineNum">     315</span>                 :             :  * set in the node.</span>
<span id="L316"><span class="lineNum">     316</span>                 :             :  *</span>
<span id="L317"><span class="lineNum">     317</span>                 :             :  * @param std::vector&lt;OutputGroup&gt;&amp; utxo_pool The UTXOs that we are choosing from. These UTXOs will be sorted in</span>
<span id="L318"><span class="lineNum">     318</span>                 :             :  *        descending order by effective value, with lower weight preferred as a tie-breaker. (We can think of an output</span>
<span id="L319"><span class="lineNum">     319</span>                 :             :  *        group with multiple as a heavier UTXO with the combined amount here.)</span>
<span id="L320"><span class="lineNum">     320</span>                 :             :  * @param const CAmount&amp; selection_target This is the minimum amount that we need for the transaction without considering change.</span>
<span id="L321"><span class="lineNum">     321</span>                 :             :  * @param const CAmount&amp; change_target The minimum budget for creating a change output, by which we increase the selection_target.</span>
<span id="L322"><span class="lineNum">     322</span>                 :             :  * @param int max_selection_weight The maximum allowed weight for a selection result to be valid.</span>
<span id="L323"><span class="lineNum">     323</span>                 :             :  * @returns The result of this coin selection algorithm, or std::nullopt</span>
<span id="L324"><span class="lineNum">     324</span>                 :             :  */</span>
<span id="L325"><span class="lineNum">     325</span>                 :<span class="tlaUNC">           0 : util::Result&lt;SelectionResult&gt; CoinGrinder(std::vector&lt;OutputGroup&gt;&amp; utxo_pool, const CAmount&amp; selection_target, CAmount change_target, int max_selection_weight)</span></span>
<span id="L326"><span class="lineNum">     326</span>                 :             : {</span>
<span id="L327"><span class="lineNum">     327</span>                 :<span class="tlaUNC">           0 :     std::sort(utxo_pool.begin(), utxo_pool.end(), descending_effval_weight);</span></span>
<span id="L328"><span class="lineNum">     328</span>                 :             :     // The sum of UTXO amounts after this UTXO index, e.g. lookahead[5] = Σ(UTXO[6+].amount)</span>
<span id="L329"><span class="lineNum">     329</span>                 :<span class="tlaUNC">           0 :     std::vector&lt;CAmount&gt; lookahead(utxo_pool.size());</span></span>
<span id="L330"><span class="lineNum">     330</span>                 :             :     // The minimum UTXO weight among the remaining UTXOs after this UTXO index, e.g. min_tail_weight[5] = min(UTXO[6+].weight)</span>
<span id="L331"><span class="lineNum">     331</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     std::vector&lt;int&gt; min_tail_weight(utxo_pool.size());</span></span>
<span id="L332"><span class="lineNum">     332</span>                 :             : </span>
<span id="L333"><span class="lineNum">     333</span>                 :             :     // Calculate lookahead values, min_tail_weights, and check that there are sufficient funds</span>
<span id="L334"><span class="lineNum">     334</span>                 :<span class="tlaUNC">           0 :     CAmount total_available = 0;</span></span>
<span id="L335"><span class="lineNum">     335</span>                 :<span class="tlaUNC">           0 :     int min_group_weight = std::numeric_limits&lt;int&gt;::max();</span></span>
<span id="L336"><span class="lineNum">     336</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     for (size_t i = 0; i &lt; utxo_pool.size(); ++i) {</span></span>
<span id="L337"><span class="lineNum">     337</span>                 :<span class="tlaUNC">           0 :         size_t index = utxo_pool.size() - 1 - i; // Loop over every element in reverse order</span></span>
<span id="L338"><span class="lineNum">     338</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         lookahead[index] = total_available;</span></span>
<span id="L339"><span class="lineNum">     339</span>                 :<span class="tlaUNC">           0 :         min_tail_weight[index] = min_group_weight;</span></span>
<span id="L340"><span class="lineNum">     340</span>                 :             :         // UTXOs with non-positive effective value must have been filtered</span>
<span id="L341"><span class="lineNum">     341</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         Assume(utxo_pool[index].GetSelectionAmount() &gt; 0);</span></span>
<span id="L342"><span class="lineNum">     342</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         total_available += utxo_pool[index].GetSelectionAmount();</span></span>
<span id="L343"><span class="lineNum">     343</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         min_group_weight = std::min(min_group_weight, utxo_pool[index].m_weight);</span></span>
<span id="L344"><span class="lineNum">     344</span>                 :             :     }</span>
<span id="L345"><span class="lineNum">     345</span>                 :             : </span>
<span id="L346"><span class="lineNum">     346</span>                 :<span class="tlaUNC">           0 :     const CAmount total_target = selection_target + change_target;</span></span>
<span id="L347"><span class="lineNum">     347</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (total_available &lt; total_target) {</span></span>
<span id="L348"><span class="lineNum">     348</span>                 :             :         // Insufficient funds</span>
<span id="L349"><span class="lineNum">     349</span>                 :<span class="tlaUNC">           0 :         return util::Error();</span></span>
<span id="L350"><span class="lineNum">     350</span>                 :             :     }</span>
<span id="L351"><span class="lineNum">     351</span>                 :             : </span>
<span id="L352"><span class="lineNum">     352</span>                 :             :     // The current selection and the best input set found so far, stored as the utxo_pool indices of the UTXOs forming them</span>
<span id="L353"><span class="lineNum">     353</span>                 :<span class="tlaUNC">           0 :     std::vector&lt;size_t&gt; curr_selection;</span></span>
<span id="L354"><span class="lineNum">     354</span>                 :<span class="tlaUNC">           0 :     std::vector&lt;size_t&gt; best_selection;</span></span>
<span id="L355"><span class="lineNum">     355</span>                 :             : </span>
<span id="L356"><span class="lineNum">     356</span>                 :             :     // The currently selected effective amount, and the effective amount of the best selection so far</span>
<span id="L357"><span class="lineNum">     357</span>                 :<span class="tlaUNC">           0 :     CAmount curr_amount = 0;</span></span>
<span id="L358"><span class="lineNum">     358</span>                 :<span class="tlaUNC">           0 :     CAmount best_selection_amount = MAX_MONEY;</span></span>
<span id="L359"><span class="lineNum">     359</span>                 :             : </span>
<span id="L360"><span class="lineNum">     360</span>                 :             :     // The weight of the currently selected input set, and the weight of the best selection</span>
<span id="L361"><span class="lineNum">     361</span>                 :<span class="tlaUNC">           0 :     int curr_weight = 0;</span></span>
<span id="L362"><span class="lineNum">     362</span>                 :<span class="tlaUNC">           0 :     int best_selection_weight = max_selection_weight; // Tie is fine, because we prefer lower selection amount</span></span>
<span id="L363"><span class="lineNum">     363</span>                 :             : </span>
<span id="L364"><span class="lineNum">     364</span>                 :             :     // Whether the input sets generated during this search have exceeded the maximum transaction weight at any point</span>
<span id="L365"><span class="lineNum">     365</span>                 :<span class="tlaUNC">           0 :     bool max_tx_weight_exceeded = false;</span></span>
<span id="L366"><span class="lineNum">     366</span>                 :             : </span>
<span id="L367"><span class="lineNum">     367</span>                 :             :     // Index of the next UTXO to consider in utxo_pool</span>
<span id="L368"><span class="lineNum">     368</span>                 :<span class="tlaUNC">           0 :     size_t next_utxo = 0;</span></span>
<span id="L369"><span class="lineNum">     369</span>                 :             : </span>
<span id="L370"><span class="lineNum">     370</span>                 :             :     /*</span>
<span id="L371"><span class="lineNum">     371</span>                 :             :      * You can think of the current selection as a vector of booleans that has decided inclusion or exclusion of all</span>
<span id="L372"><span class="lineNum">     372</span>                 :             :      * UTXOs before `next_utxo`. When we consider the next UTXO, we extend this hypothetical boolean vector either with</span>
<span id="L373"><span class="lineNum">     373</span>                 :             :      * a true value if the UTXO is included or a false value if it is omitted. The equivalent state is stored more</span>
<span id="L374"><span class="lineNum">     374</span>                 :             :      * compactly as the list of indices of the included UTXOs and the `next_utxo` index.</span>
<span id="L375"><span class="lineNum">     375</span>                 :             :      *</span>
<span id="L376"><span class="lineNum">     376</span>                 :             :      * We can never find a new solution by deselecting a UTXO, because we then revisit a previously evaluated</span>
<span id="L377"><span class="lineNum">     377</span>                 :             :      * selection. Therefore, we only need to check whether we found a new solution _after adding_ a new UTXO.</span>
<span id="L378"><span class="lineNum">     378</span>                 :             :      *</span>
<span id="L379"><span class="lineNum">     379</span>                 :             :      * Each iteration of CoinGrinder starts by selecting the `next_utxo` and evaluating the current selection. We</span>
<span id="L380"><span class="lineNum">     380</span>                 :             :      * use three state transitions to progress from the current selection to the next promising selection:</span>
<span id="L381"><span class="lineNum">     381</span>                 :             :      *</span>
<span id="L382"><span class="lineNum">     382</span>                 :             :      * - EXPLORE inclusion branch: We do not have sufficient funds, yet. Add `next_utxo` to the current selection, then</span>
<span id="L383"><span class="lineNum">     383</span>                 :             :      *                             nominate the direct successor of the just selected UTXO as our `next_utxo` for the</span>
<span id="L384"><span class="lineNum">     384</span>                 :             :      *                             following iteration.</span>
<span id="L385"><span class="lineNum">     385</span>                 :             :      *</span>
<span id="L386"><span class="lineNum">     386</span>                 :             :      *                             Example:</span>
<span id="L387"><span class="lineNum">     387</span>                 :             :      *                                 Current Selection: {0, 5, 7}</span>
<span id="L388"><span class="lineNum">     388</span>                 :             :      *                                 Evaluation: EXPLORE, next_utxo: 8</span>
<span id="L389"><span class="lineNum">     389</span>                 :             :      *                                 Next Selection: {0, 5, 7, 8}</span>
<span id="L390"><span class="lineNum">     390</span>                 :             :      *</span>
<span id="L391"><span class="lineNum">     391</span>                 :             :      * - SHIFT to omission branch: Adding more UTXOs to the current selection cannot produce a solution that is better</span>
<span id="L392"><span class="lineNum">     392</span>                 :             :      *                             than the current best, e.g. the current selection weight exceeds the max weight or</span>
<span id="L393"><span class="lineNum">     393</span>                 :             :      *                             the current selection amount is equal to or greater than the target.</span>
<span id="L394"><span class="lineNum">     394</span>                 :             :      *                             We designate our `next_utxo` the one after the tail of our current selection, then</span>
<span id="L395"><span class="lineNum">     395</span>                 :             :      *                             deselect the tail of our current selection.</span>
<span id="L396"><span class="lineNum">     396</span>                 :             :      *</span>
<span id="L397"><span class="lineNum">     397</span>                 :             :      *                             Example:</span>
<span id="L398"><span class="lineNum">     398</span>                 :             :      *                                 Current Selection: {0, 5, 7}</span>
<span id="L399"><span class="lineNum">     399</span>                 :             :      *                                 Evaluation: SHIFT, next_utxo: 8, omit last selected: {0, 5}</span>
<span id="L400"><span class="lineNum">     400</span>                 :             :      *                                 Next Selection: {0, 5, 8}</span>
<span id="L401"><span class="lineNum">     401</span>                 :             :      *</span>
<span id="L402"><span class="lineNum">     402</span>                 :             :      * - CUT entire subtree:       We have exhausted the inclusion branch for the penultimately selected UTXO, both the</span>
<span id="L403"><span class="lineNum">     403</span>                 :             :      *                             inclusion and the omission branch of the current prefix are barren. E.g. we have</span>
<span id="L404"><span class="lineNum">     404</span>                 :             :      *                             reached the end of the UTXO pool, so neither further EXPLORING nor SHIFTING can find</span>
<span id="L405"><span class="lineNum">     405</span>                 :             :      *                             any solutions. We designate our `next_utxo` the one after our penultimate selected,</span>
<span id="L406"><span class="lineNum">     406</span>                 :             :      *                             then deselect both the last and penultimate selected.</span>
<span id="L407"><span class="lineNum">     407</span>                 :             :      *</span>
<span id="L408"><span class="lineNum">     408</span>                 :             :      *                             Example:</span>
<span id="L409"><span class="lineNum">     409</span>                 :             :      *                                 Current Selection: {0, 5, 7}</span>
<span id="L410"><span class="lineNum">     410</span>                 :             :      *                                 Evaluation: CUT, next_utxo: 6, omit two last selected: {0}</span>
<span id="L411"><span class="lineNum">     411</span>                 :             :      *                                 Next Selection: {0, 6}</span>
<span id="L412"><span class="lineNum">     412</span>                 :             :      */</span>
<span id="L413"><span class="lineNum">     413</span>                 :<span class="tlaUNC">           0 :     auto deselect_last = [&amp;]() {</span></span>
<span id="L414"><span class="lineNum">     414</span>                 :<span class="tlaUNC">           0 :         OutputGroup&amp; utxo = utxo_pool[curr_selection.back()];</span></span>
<span id="L415"><span class="lineNum">     415</span>                 :<span class="tlaUNC">           0 :         curr_amount -= utxo.GetSelectionAmount();</span></span>
<span id="L416"><span class="lineNum">     416</span>                 :<span class="tlaUNC">           0 :         curr_weight -= utxo.m_weight;</span></span>
<span id="L417"><span class="lineNum">     417</span>                 :<span class="tlaUNC">           0 :         curr_selection.pop_back();</span></span>
<span id="L418"><span class="lineNum">     418</span>                 :<span class="tlaUNC">           0 :     };</span></span>
<span id="L419"><span class="lineNum">     419</span>                 :             : </span>
<span id="L420"><span class="lineNum">     420</span>                 :<span class="tlaUNC">           0 :     SelectionResult result(selection_target, SelectionAlgorithm::CG);</span></span>
<span id="L421"><span class="lineNum">     421</span>                 :<span class="tlaUNC">           0 :     bool is_done = false;</span></span>
<span id="L422"><span class="lineNum">     422</span>                 :<span class="tlaUNC">           0 :     size_t curr_try = 0;</span></span>
<span id="L423"><span class="lineNum">     423</span>                 :<span class="tlaUNC">           0 :     while (!is_done) {</span></span>
<span id="L424"><span class="lineNum">     424</span>                 :<span class="tlaUNC">           0 :         bool should_shift{false}, should_cut{false};</span></span>
<span id="L425"><span class="lineNum">     425</span>                 :             :         // Select `next_utxo`</span>
<span id="L426"><span class="lineNum">     426</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         OutputGroup&amp; utxo = utxo_pool[next_utxo];</span></span>
<span id="L427"><span class="lineNum">     427</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         curr_amount += utxo.GetSelectionAmount();</span></span>
<span id="L428"><span class="lineNum">     428</span>                 :<span class="tlaUNC">           0 :         curr_weight += utxo.m_weight;</span></span>
<span id="L429"><span class="lineNum">     429</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         curr_selection.push_back(next_utxo);</span></span>
<span id="L430"><span class="lineNum">     430</span>                 :<span class="tlaUNC">           0 :         ++next_utxo;</span></span>
<span id="L431"><span class="lineNum">     431</span>                 :<span class="tlaUNC">           0 :         ++curr_try;</span></span>
<span id="L432"><span class="lineNum">     432</span>                 :             : </span>
<span id="L433"><span class="lineNum">     433</span>                 :             :         // EVALUATE current selection: check for solutions and see whether we can CUT or SHIFT before EXPLORING further</span>
<span id="L434"><span class="lineNum">     434</span>                 :<span class="tlaUNC">           0 :         auto curr_tail = curr_selection.back();</span></span>
<span id="L435"><span class="lineNum">     435</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (curr_amount + lookahead[curr_tail] &lt; total_target) {</span></span>
<span id="L436"><span class="lineNum">     436</span>                 :             :             // Insufficient funds with lookahead: CUT</span>
<span id="L437"><span class="lineNum">     437</span>                 :             :             should_cut = true;</span>
<span id="L438"><span class="lineNum">     438</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         } else if (curr_weight &gt; best_selection_weight) {</span></span>
<span id="L439"><span class="lineNum">     439</span>                 :             :             // best_selection_weight is initialized to max_selection_weight</span>
<span id="L440"><span class="lineNum">     440</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (curr_weight &gt; max_selection_weight) max_tx_weight_exceeded = true;</span></span>
<span id="L441"><span class="lineNum">     441</span>                 :             :             // Worse weight than best solution. More UTXOs only increase weight:</span>
<span id="L442"><span class="lineNum">     442</span>                 :             :             // CUT if last selected group had minimal weight, else SHIFT</span>
<span id="L443"><span class="lineNum">     443</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (utxo_pool[curr_tail].m_weight &lt;= min_tail_weight[curr_tail]) {</span></span>
<span id="L444"><span class="lineNum">     444</span>                 :             :                 should_cut = true;</span>
<span id="L445"><span class="lineNum">     445</span>                 :             :             } else {</span>
<span id="L446"><span class="lineNum">     446</span>                 :<span class="tlaUNC">           0 :                 should_shift  = true;</span></span>
<span id="L447"><span class="lineNum">     447</span>                 :             :             }</span>
<span id="L448"><span class="lineNum">     448</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         } else if (curr_amount &gt;= total_target) {</span></span>
<span id="L449"><span class="lineNum">     449</span>                 :             :             // Success, adding more weight cannot be better: SHIFT</span>
<span id="L450"><span class="lineNum">     450</span>                 :<span class="tlaUNC">           0 :             should_shift  = true;</span></span>
<span id="L451"><span class="lineNum">     451</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :             if (curr_weight &lt; best_selection_weight || (curr_weight == best_selection_weight &amp;&amp; curr_amount &lt; best_selection_amount)) {</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L452"><span class="lineNum">     452</span>                 :             :                 // New lowest weight, or same weight with fewer funds tied up</span>
<span id="L453"><span class="lineNum">     453</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 best_selection = curr_selection;</span></span>
<span id="L454"><span class="lineNum">     454</span>                 :<span class="tlaUNC">           0 :                 best_selection_weight = curr_weight;</span></span>
<span id="L455"><span class="lineNum">     455</span>                 :<span class="tlaUNC">           0 :                 best_selection_amount = curr_amount;</span></span>
<span id="L456"><span class="lineNum">     456</span>                 :             :             }</span>
<span id="L457"><span class="lineNum">     457</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :         } else if (!best_selection.empty() &amp;&amp; curr_weight + int64_t{min_tail_weight[curr_tail]} * ((total_target - curr_amount + utxo_pool[curr_tail].GetSelectionAmount() - 1) / utxo_pool[curr_tail].GetSelectionAmount()) &gt; best_selection_weight) {</span></span>
<span class="lineNum">        </span>    <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span><span class="tlaUNC" title="Branch 6 was not executed"> # </span><span class="tlaUNC" title="Branch 7 was not executed"> # </span>]
<span id="L458"><span class="lineNum">     458</span>                 :             :             // Compare minimal tail weight and last selected amount with the amount missing to gauge whether a better weight is still possible.</span>
<span id="L459"><span class="lineNum">     459</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (utxo_pool[curr_tail].m_weight &lt;= min_tail_weight[curr_tail]) {</span></span>
<span id="L460"><span class="lineNum">     460</span>                 :             :                 should_cut = true;</span>
<span id="L461"><span class="lineNum">     461</span>                 :             :             } else {</span>
<span id="L462"><span class="lineNum">     462</span>                 :<span class="tlaUNC">           0 :                 should_shift = true;</span></span>
<span id="L463"><span class="lineNum">     463</span>                 :             :             }</span>
<span id="L464"><span class="lineNum">     464</span>                 :             :         }</span>
<span id="L465"><span class="lineNum">     465</span>                 :             : </span>
<span id="L466"><span class="lineNum">     466</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (curr_try &gt;= TOTAL_TRIES) {</span></span>
<span id="L467"><span class="lineNum">     467</span>                 :             :             // Solution is not guaranteed to be optimal if `curr_try` hit TOTAL_TRIES</span>
<span id="L468"><span class="lineNum">     468</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             result.SetAlgoCompleted(false);</span></span>
<span id="L469"><span class="lineNum">     469</span>                 :             :             break;</span>
<span id="L470"><span class="lineNum">     470</span>                 :             :         }</span>
<span id="L471"><span class="lineNum">     471</span>                 :             : </span>
<span id="L472"><span class="lineNum">     472</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (next_utxo == utxo_pool.size()) {</span></span>
<span id="L473"><span class="lineNum">     473</span>                 :             :             // Last added UTXO was end of UTXO pool, nothing left to add on inclusion or omission branch: CUT</span>
<span id="L474"><span class="lineNum">     474</span>                 :             :             should_cut = true;</span>
<span id="L475"><span class="lineNum">     475</span>                 :             :         }</span>
<span id="L476"><span class="lineNum">     476</span>                 :             : </span>
<span id="L477"><span class="lineNum">     477</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (should_cut) {</span></span>
<span id="L478"><span class="lineNum">     478</span>                 :             :             // Neither adding to the current selection nor exploring the omission branch of the last selected UTXO can</span>
<span id="L479"><span class="lineNum">     479</span>                 :             :             // find any solutions. Redirect to exploring the Omission branch of the penultimate selected UTXO (i.e.</span>
<span id="L480"><span class="lineNum">     480</span>                 :             :             // set `next_utxo` to one after the penultimate selected, then deselect the last two selected UTXOs)</span>
<span id="L481"><span class="lineNum">     481</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             deselect_last();</span></span>
<span id="L482"><span class="lineNum">     482</span>                 :             :             should_shift  = true;</span>
<span id="L483"><span class="lineNum">     483</span>                 :             :         }</span>
<span id="L484"><span class="lineNum">     484</span>                 :             : </span>
<span id="L485"><span class="lineNum">     485</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         while (should_shift) {</span></span>
<span id="L486"><span class="lineNum">     486</span>                 :             :             // Set `next_utxo` to one after last selected, then deselect last selected UTXO</span>
<span id="L487"><span class="lineNum">     487</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (curr_selection.empty()) {</span></span>
<span id="L488"><span class="lineNum">     488</span>                 :             :                 // Exhausted search space before running into attempt limit</span>
<span id="L489"><span class="lineNum">     489</span>                 :<span class="tlaUNC">           0 :                 is_done = true;</span></span>
<span id="L490"><span class="lineNum">     490</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 result.SetAlgoCompleted(true);</span></span>
<span id="L491"><span class="lineNum">     491</span>                 :             :                 break;</span>
<span id="L492"><span class="lineNum">     492</span>                 :             :             }</span>
<span id="L493"><span class="lineNum">     493</span>                 :<span class="tlaUNC">           0 :             next_utxo = curr_selection.back() + 1;</span></span>
<span id="L494"><span class="lineNum">     494</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             deselect_last();</span></span>
<span id="L495"><span class="lineNum">     495</span>                 :<span class="tlaUNC">           0 :             should_shift  = false;</span></span>
<span id="L496"><span class="lineNum">     496</span>                 :             : </span>
<span id="L497"><span class="lineNum">     497</span>                 :             :             // After SHIFTing to an omission branch, the `next_utxo` might have the same effective value as the UTXO we</span>
<span id="L498"><span class="lineNum">     498</span>                 :             :             // just omitted. Since lower weight is our tiebreaker on UTXOs with equal effective value for sorting, if it</span>
<span id="L499"><span class="lineNum">     499</span>                 :             :             // ties on the effective value, it _must_ have the same weight (i.e. be a &quot;clone&quot; of the prior UTXO) or a</span>
<span id="L500"><span class="lineNum">     500</span>                 :             :             // higher weight. If so, selecting `next_utxo` would produce an equivalent or worse selection as one we</span>
<span id="L501"><span class="lineNum">     501</span>                 :             :             // previously evaluated. In that case, increment `next_utxo` until we find a UTXO with a differing amount.</span>
<span id="L502"><span class="lineNum">     502</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :             while (utxo_pool[next_utxo - 1].GetSelectionAmount() == utxo_pool[next_utxo].GetSelectionAmount()) {</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L503"><span class="lineNum">     503</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 if (next_utxo &gt;= utxo_pool.size() - 1) {</span></span>
<span id="L504"><span class="lineNum">     504</span>                 :             :                     // Reached end of UTXO pool skipping clones: SHIFT instead</span>
<span id="L505"><span class="lineNum">     505</span>                 :             :                     should_shift = true;</span>
<span id="L506"><span class="lineNum">     506</span>                 :             :                     break;</span>
<span id="L507"><span class="lineNum">     507</span>                 :             :                 }</span>
<span id="L508"><span class="lineNum">     508</span>                 :             :                 // Skip clone: previous UTXO is equivalent and unselected</span>
<span id="L509"><span class="lineNum">     509</span>                 :<span class="tlaUNC">           0 :                 ++next_utxo;</span></span>
<span id="L510"><span class="lineNum">     510</span>                 :             :             }</span>
<span id="L511"><span class="lineNum">     511</span>                 :             :         }</span>
<span id="L512"><span class="lineNum">     512</span>                 :             :     }</span>
<span id="L513"><span class="lineNum">     513</span>                 :             : </span>
<span id="L514"><span class="lineNum">     514</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     result.SetSelectionsEvaluated(curr_try);</span></span>
<span id="L515"><span class="lineNum">     515</span>                 :             : </span>
<span id="L516"><span class="lineNum">     516</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (best_selection.empty()) {</span></span>
<span id="L517"><span class="lineNum">     517</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         return max_tx_weight_exceeded ? ErrorMaxWeightExceeded() : util::Error();</span></span>
<span id="L518"><span class="lineNum">     518</span>                 :             :     }</span>
<span id="L519"><span class="lineNum">     519</span>                 :             : </span>
<span id="L520"><span class="lineNum">     520</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     for (const size_t&amp; i : best_selection) {</span></span>
<span id="L521"><span class="lineNum">     521</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         result.AddInput(utxo_pool[i]);</span></span>
<span id="L522"><span class="lineNum">     522</span>                 :             :     }</span>
<span id="L523"><span class="lineNum">     523</span>                 :             : </span>
<span id="L524"><span class="lineNum">     524</span>                 :<span class="tlaUNC">           0 :     return result;</span></span>
<span id="L525"><span class="lineNum">     525</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L526"><span class="lineNum">     526</span>                 :             : </span>
<span id="L527"><span class="lineNum">     527</span>                 :             : class MinOutputGroupComparator</span>
<span id="L528"><span class="lineNum">     528</span>                 :             : {</span>
<span id="L529"><span class="lineNum">     529</span>                 :             : public:</span>
<span id="L530"><span class="lineNum">     530</span>                 :<span class="tlaUNC">           0 :     int operator() (const OutputGroup&amp; group1, const OutputGroup&amp; group2) const</span></span>
<span id="L531"><span class="lineNum">     531</span>                 :             :     {</span>
<span id="L532"><span class="lineNum">     532</span>                 :<span class="tlaUNC">           0 :         return group1.GetSelectionAmount() &gt; group2.GetSelectionAmount();</span></span>
<span id="L533"><span class="lineNum">     533</span>                 :             :     }</span>
<span id="L534"><span class="lineNum">     534</span>                 :             : };</span>
<span id="L535"><span class="lineNum">     535</span>                 :             : </span>
<span id="L536"><span class="lineNum">     536</span>                 :<span class="tlaUNC">           0 : util::Result&lt;SelectionResult&gt; SelectCoinsSRD(const std::vector&lt;OutputGroup&gt;&amp; utxo_pool, CAmount target_value, CAmount change_fee, FastRandomContext&amp; rng,</span></span>
<span id="L537"><span class="lineNum">     537</span>                 :             :                                              int max_selection_weight)</span>
<span id="L538"><span class="lineNum">     538</span>                 :             : {</span>
<span id="L539"><span class="lineNum">     539</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     SelectionResult result(target_value, SelectionAlgorithm::SRD);</span></span>
<span id="L540"><span class="lineNum">     540</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     std::priority_queue&lt;OutputGroup, std::vector&lt;OutputGroup&gt;, MinOutputGroupComparator&gt; heap;</span></span>
<span id="L541"><span class="lineNum">     541</span>                 :             : </span>
<span id="L542"><span class="lineNum">     542</span>                 :             :     // Include change for SRD as we want to avoid making really small change if the selection just</span>
<span id="L543"><span class="lineNum">     543</span>                 :             :     // barely meets the target. Just use the lower bound change target instead of the randomly</span>
<span id="L544"><span class="lineNum">     544</span>                 :             :     // generated one, since SRD will result in a random change amount anyway; avoid making the</span>
<span id="L545"><span class="lineNum">     545</span>                 :             :     // target needlessly large.</span>
<span id="L546"><span class="lineNum">     546</span>                 :<span class="tlaUNC">           0 :     target_value += CHANGE_LOWER + change_fee;</span></span>
<span id="L547"><span class="lineNum">     547</span>                 :             : </span>
<span id="L548"><span class="lineNum">     548</span>                 :<span class="tlaUNC">           0 :     std::vector&lt;size_t&gt; indexes;</span></span>
<span id="L549"><span class="lineNum">     549</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     indexes.resize(utxo_pool.size());</span></span>
<span id="L550"><span class="lineNum">     550</span>                 :<span class="tlaUNC">           0 :     std::iota(indexes.begin(), indexes.end(), 0);</span></span>
<span id="L551"><span class="lineNum">     551</span>                 :<span class="tlaUNC">           0 :     std::shuffle(indexes.begin(), indexes.end(), rng);</span></span>
<span id="L552"><span class="lineNum">     552</span>                 :             : </span>
<span id="L553"><span class="lineNum">     553</span>                 :<span class="tlaUNC">           0 :     CAmount selected_eff_value = 0;</span></span>
<span id="L554"><span class="lineNum">     554</span>                 :<span class="tlaUNC">           0 :     int weight = 0;</span></span>
<span id="L555"><span class="lineNum">     555</span>                 :<span class="tlaUNC">           0 :     bool max_tx_weight_exceeded = false;</span></span>
<span id="L556"><span class="lineNum">     556</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     for (const size_t i : indexes) {</span></span>
<span id="L557"><span class="lineNum">     557</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         const OutputGroup&amp; group = utxo_pool.at(i);</span></span>
<span id="L558"><span class="lineNum">     558</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         Assume(group.GetSelectionAmount() &gt; 0);</span></span>
<span id="L559"><span class="lineNum">     559</span>                 :             : </span>
<span id="L560"><span class="lineNum">     560</span>                 :             :         // Add group to selection</span>
<span id="L561"><span class="lineNum">     561</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         heap.push(group);</span></span>
<span id="L562"><span class="lineNum">     562</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         selected_eff_value += group.GetSelectionAmount();</span></span>
<span id="L563"><span class="lineNum">     563</span>                 :<span class="tlaUNC">           0 :         weight += group.m_weight;</span></span>
<span id="L564"><span class="lineNum">     564</span>                 :             : </span>
<span id="L565"><span class="lineNum">     565</span>                 :             :         // If the selection weight exceeds the maximum allowed size, remove the least valuable inputs until we</span>
<span id="L566"><span class="lineNum">     566</span>                 :             :         // are below max weight.</span>
<span id="L567"><span class="lineNum">     567</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (weight &gt; max_selection_weight) {</span></span>
<span id="L568"><span class="lineNum">     568</span>                 :<span class="tlaUNC">           0 :             max_tx_weight_exceeded = true; // mark it in case we don't find any useful result.</span></span>
<span id="L569"><span class="lineNum">     569</span>                 :<span class="tlaUNC">           0 :             do {</span></span>
<span id="L570"><span class="lineNum">     570</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 const OutputGroup&amp; to_remove_group = heap.top();</span></span>
<span id="L571"><span class="lineNum">     571</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 selected_eff_value -= to_remove_group.GetSelectionAmount();</span></span>
<span id="L572"><span class="lineNum">     572</span>                 :<span class="tlaUNC">           0 :                 weight -= to_remove_group.m_weight;</span></span>
<span id="L573"><span class="lineNum">     573</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 heap.pop();</span></span>
<span id="L574"><span class="lineNum">     574</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :             } while (!heap.empty() &amp;&amp; weight &gt; max_selection_weight);</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L575"><span class="lineNum">     575</span>                 :             :         }</span>
<span id="L576"><span class="lineNum">     576</span>                 :             : </span>
<span id="L577"><span class="lineNum">     577</span>                 :             :         // Now check if we are above the target</span>
<span id="L578"><span class="lineNum">     578</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (selected_eff_value &gt;= target_value) {</span></span>
<span id="L579"><span class="lineNum">     579</span>                 :             :             // Result found, add it.</span>
<span id="L580"><span class="lineNum">     580</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             while (!heap.empty()) {</span></span>
<span id="L581"><span class="lineNum">     581</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 result.AddInput(heap.top());</span></span>
<span id="L582"><span class="lineNum">     582</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 heap.pop();</span></span>
<span id="L583"><span class="lineNum">     583</span>                 :             :             }</span>
<span id="L584"><span class="lineNum">     584</span>                 :<span class="tlaUNC">           0 :             return result;</span></span>
<span id="L585"><span class="lineNum">     585</span>                 :             :         }</span>
<span id="L586"><span class="lineNum">     586</span>                 :             :     }</span>
<span id="L587"><span class="lineNum">     587</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     return max_tx_weight_exceeded ? ErrorMaxWeightExceeded() : util::Error();</span></span>
<span id="L588"><span class="lineNum">     588</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L589"><span class="lineNum">     589</span>                 :             : </span>
<span id="L590"><span class="lineNum">     590</span>                 :             : /** Find a subset of the OutputGroups that is at least as large as, but as close as possible to, the</span>
<span id="L591"><span class="lineNum">     591</span>                 :             :  * target amount; solve subset sum.</span>
<span id="L592"><span class="lineNum">     592</span>                 :             :  * param@[in]   groups          OutputGroups to choose from, sorted by value in descending order.</span>
<span id="L593"><span class="lineNum">     593</span>                 :             :  * param@[in]   nTotalLower     Total (effective) value of the UTXOs in groups.</span>
<span id="L594"><span class="lineNum">     594</span>                 :             :  * param@[in]   nTargetValue    Subset sum target, not including change.</span>
<span id="L595"><span class="lineNum">     595</span>                 :             :  * param@[out]  vfBest          Boolean vector representing the subset chosen that is closest to</span>
<span id="L596"><span class="lineNum">     596</span>                 :             :  *                              nTargetValue, with indices corresponding to groups. If the ith</span>
<span id="L597"><span class="lineNum">     597</span>                 :             :  *                              entry is true, that means the ith group in groups was selected.</span>
<span id="L598"><span class="lineNum">     598</span>                 :             :  * param@[out]  nBest           Total amount of subset chosen that is closest to nTargetValue.</span>
<span id="L599"><span class="lineNum">     599</span>                 :             :  * paramp[in]   max_selection_weight  The maximum allowed weight for a selection result to be valid.</span>
<span id="L600"><span class="lineNum">     600</span>                 :             :  * param@[in]   iterations      Maximum number of tries.</span>
<span id="L601"><span class="lineNum">     601</span>                 :             :  */</span>
<span id="L602"><span class="lineNum">     602</span>                 :<span class="tlaUNC">           0 : static void ApproximateBestSubset(FastRandomContext&amp; insecure_rand, const std::vector&lt;OutputGroup&gt;&amp; groups,</span></span>
<span id="L603"><span class="lineNum">     603</span>                 :             :                                   const CAmount&amp; nTotalLower, const CAmount&amp; nTargetValue,</span>
<span id="L604"><span class="lineNum">     604</span>                 :             :                                   std::vector&lt;char&gt;&amp; vfBest, CAmount&amp; nBest, int max_selection_weight, int iterations = 1000)</span>
<span id="L605"><span class="lineNum">     605</span>                 :             : {</span>
<span id="L606"><span class="lineNum">     606</span>                 :<span class="tlaUNC">           0 :     std::vector&lt;char&gt; vfIncluded;</span></span>
<span id="L607"><span class="lineNum">     607</span>                 :             : </span>
<span id="L608"><span class="lineNum">     608</span>                 :             :     // Worst case &quot;best&quot; approximation is just all of the groups.</span>
<span id="L609"><span class="lineNum">     609</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     vfBest.assign(groups.size(), true);</span></span>
<span id="L610"><span class="lineNum">     610</span>                 :<span class="tlaUNC">           0 :     nBest = nTotalLower;</span></span>
<span id="L611"><span class="lineNum">     611</span>                 :             : </span>
<span id="L612"><span class="lineNum">     612</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     for (int nRep = 0; nRep &lt; iterations &amp;&amp; nBest != nTargetValue; nRep++)</span></span>
<span id="L613"><span class="lineNum">     613</span>                 :             :     {</span>
<span id="L614"><span class="lineNum">     614</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         vfIncluded.assign(groups.size(), false);</span></span>
<span id="L615"><span class="lineNum">     615</span>                 :             :         CAmount nTotal = 0;</span>
<span id="L616"><span class="lineNum">     616</span>                 :             :         int selected_coins_weight{0};</span>
<span id="L617"><span class="lineNum">     617</span>                 :             :         bool fReachedTarget = false;</span>
<span id="L618"><span class="lineNum">     618</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         for (int nPass = 0; nPass &lt; 2 &amp;&amp; !fReachedTarget; nPass++)</span></span>
<span id="L619"><span class="lineNum">     619</span>                 :             :         {</span>
<span id="L620"><span class="lineNum">     620</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             for (unsigned int i = 0; i &lt; groups.size(); i++)</span></span>
<span id="L621"><span class="lineNum">     621</span>                 :             :             {</span>
<span id="L622"><span class="lineNum">     622</span>                 :             :                 //The solver here uses a randomized algorithm,</span>
<span id="L623"><span class="lineNum">     623</span>                 :             :                 //the randomness serves no real security purpose but is just</span>
<span id="L624"><span class="lineNum">     624</span>                 :             :                 //needed to prevent degenerate behavior and it is important</span>
<span id="L625"><span class="lineNum">     625</span>                 :             :                 //that the rng is fast. We do not use a constant random sequence,</span>
<span id="L626"><span class="lineNum">     626</span>                 :             :                 //because there may be some privacy improvement by making</span>
<span id="L627"><span class="lineNum">     627</span>                 :             :                 //the selection random.</span>
<span id="L628"><span class="lineNum">     628</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 if (nPass == 0 ? insecure_rand.randbool() : !vfIncluded[i])</span></span>
<span id="L629"><span class="lineNum">     629</span>                 :             :                 {</span>
<span id="L630"><span class="lineNum">     630</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                     nTotal += groups[i].GetSelectionAmount();</span></span>
<span id="L631"><span class="lineNum">     631</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                     selected_coins_weight += groups[i].m_weight;</span></span>
<span id="L632"><span class="lineNum">     632</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                     vfIncluded[i] = true;</span></span>
<span id="L633"><span class="lineNum">     633</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :                     if (nTotal &gt;= nTargetValue &amp;&amp; selected_coins_weight &lt;= max_selection_weight) {</span></span>
<span id="L634"><span class="lineNum">     634</span>                 :<span class="tlaUNC">           0 :                         fReachedTarget = true;</span></span>
<span id="L635"><span class="lineNum">     635</span>                 :             :                         // If the total is between nTargetValue and nBest, it's our new best</span>
<span id="L636"><span class="lineNum">     636</span>                 :             :                         // approximation.</span>
<span id="L637"><span class="lineNum">     637</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                         if (nTotal &lt; nBest)</span></span>
<span id="L638"><span class="lineNum">     638</span>                 :             :                         {</span>
<span id="L639"><span class="lineNum">     639</span>                 :<span class="tlaUNC">           0 :                             nBest = nTotal;</span></span>
<span id="L640"><span class="lineNum">     640</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                             vfBest = vfIncluded;</span></span>
<span id="L641"><span class="lineNum">     641</span>                 :             :                         }</span>
<span id="L642"><span class="lineNum">     642</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                         nTotal -= groups[i].GetSelectionAmount();</span></span>
<span id="L643"><span class="lineNum">     643</span>                 :<span class="tlaUNC">           0 :                         selected_coins_weight -= groups[i].m_weight;</span></span>
<span id="L644"><span class="lineNum">     644</span>                 :<span class="tlaUNC">           0 :                         vfIncluded[i] = false;</span></span>
<span id="L645"><span class="lineNum">     645</span>                 :             :                     }</span>
<span id="L646"><span class="lineNum">     646</span>                 :             :                 }</span>
<span id="L647"><span class="lineNum">     647</span>                 :             :             }</span>
<span id="L648"><span class="lineNum">     648</span>                 :             :         }</span>
<span id="L649"><span class="lineNum">     649</span>                 :             :     }</span>
<span id="L650"><span class="lineNum">     650</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L651"><span class="lineNum">     651</span>                 :             : </span>
<span id="L652"><span class="lineNum">     652</span>                 :<span class="tlaUNC">           0 : util::Result&lt;SelectionResult&gt; KnapsackSolver(std::vector&lt;OutputGroup&gt;&amp; groups, const CAmount&amp; nTargetValue,</span></span>
<span id="L653"><span class="lineNum">     653</span>                 :             :                                              CAmount change_target, FastRandomContext&amp; rng, int max_selection_weight)</span>
<span id="L654"><span class="lineNum">     654</span>                 :             : {</span>
<span id="L655"><span class="lineNum">     655</span>                 :<span class="tlaUNC">           0 :     SelectionResult result(nTargetValue, SelectionAlgorithm::KNAPSACK);</span></span>
<span id="L656"><span class="lineNum">     656</span>                 :             : </span>
<span id="L657"><span class="lineNum">     657</span>                 :<span class="tlaUNC">           0 :     bool max_weight_exceeded{false};</span></span>
<span id="L658"><span class="lineNum">     658</span>                 :             :     // List of values less than target</span>
<span id="L659"><span class="lineNum">     659</span>                 :<span class="tlaUNC">           0 :     std::optional&lt;OutputGroup&gt; lowest_larger;</span></span>
<span id="L660"><span class="lineNum">     660</span>                 :             :     // Groups with selection amount smaller than the target and any change we might produce.</span>
<span id="L661"><span class="lineNum">     661</span>                 :             :     // Don't include groups larger than this, because they will only cause us to overshoot.</span>
<span id="L662"><span class="lineNum">     662</span>                 :<span class="tlaUNC">           0 :     std::vector&lt;OutputGroup&gt; applicable_groups;</span></span>
<span id="L663"><span class="lineNum">     663</span>                 :<span class="tlaUNC">           0 :     CAmount nTotalLower = 0;</span></span>
<span id="L664"><span class="lineNum">     664</span>                 :             : </span>
<span id="L665"><span class="lineNum">     665</span>                 :<span class="tlaUNC">           0 :     std::shuffle(groups.begin(), groups.end(), rng);</span></span>
<span id="L666"><span class="lineNum">     666</span>                 :             : </span>
<span id="L667"><span class="lineNum">     667</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     for (const OutputGroup&amp; group : groups) {</span></span>
<span id="L668"><span class="lineNum">     668</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (group.m_weight &gt; max_selection_weight) {</span></span>
<span id="L669"><span class="lineNum">     669</span>                 :<span class="tlaUNC">           0 :             max_weight_exceeded = true;</span></span>
<span id="L670"><span class="lineNum">     670</span>                 :<span class="tlaUNC">           0 :             continue;</span></span>
<span id="L671"><span class="lineNum">     671</span>                 :             :         }</span>
<span id="L672"><span class="lineNum">     672</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (group.GetSelectionAmount() == nTargetValue) {</span></span>
<span id="L673"><span class="lineNum">     673</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             result.AddInput(group);</span></span>
<span id="L674"><span class="lineNum">     674</span>                 :<span class="tlaUNC">           0 :             return result;</span></span>
<span id="L675"><span class="lineNum">     675</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         } else if (group.GetSelectionAmount() &lt; nTargetValue + change_target) {</span></span>
<span id="L676"><span class="lineNum">     676</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             applicable_groups.push_back(group);</span></span>
<span id="L677"><span class="lineNum">     677</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             nTotalLower += group.GetSelectionAmount();</span></span>
<span id="L678"><span class="lineNum">     678</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :         } else if (!lowest_larger || group.GetSelectionAmount() &lt; lowest_larger-&gt;GetSelectionAmount()) {</span></span>
<span class="lineNum">        </span>    <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span><span class="tlaUNC" title="Branch 6 was not executed"> # </span><span class="tlaUNC" title="Branch 7 was not executed"> # </span>]
<span id="L679"><span class="lineNum">     679</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             lowest_larger = group;</span></span>
<span id="L680"><span class="lineNum">     680</span>                 :             :         }</span>
<span id="L681"><span class="lineNum">     681</span>                 :             :     }</span>
<span id="L682"><span class="lineNum">     682</span>                 :             : </span>
<span id="L683"><span class="lineNum">     683</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (nTotalLower == nTargetValue) {</span></span>
<span id="L684"><span class="lineNum">     684</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         for (const auto&amp; group : applicable_groups) {</span></span>
<span id="L685"><span class="lineNum">     685</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             result.AddInput(group);</span></span>
<span id="L686"><span class="lineNum">     686</span>                 :             :         }</span>
<span id="L687"><span class="lineNum">     687</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (result.GetWeight() &lt;= max_selection_weight) return result;</span></span>
<span id="L688"><span class="lineNum">     688</span>                 :<span class="tlaUNC">           0 :         else max_weight_exceeded = true;</span></span>
<span id="L689"><span class="lineNum">     689</span>                 :             : </span>
<span id="L690"><span class="lineNum">     690</span>                 :             :         // Try something else</span>
<span id="L691"><span class="lineNum">     691</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         result.Clear();</span></span>
<span id="L692"><span class="lineNum">     692</span>                 :             :     }</span>
<span id="L693"><span class="lineNum">     693</span>                 :             : </span>
<span id="L694"><span class="lineNum">     694</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (nTotalLower &lt; nTargetValue) {</span></span>
<span id="L695"><span class="lineNum">     695</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (!lowest_larger) {</span></span>
<span id="L696"><span class="lineNum">     696</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (max_weight_exceeded) return ErrorMaxWeightExceeded();</span></span>
<span id="L697"><span class="lineNum">     697</span>                 :<span class="tlaUNC">           0 :             return util::Error();</span></span>
<span id="L698"><span class="lineNum">     698</span>                 :             :         }</span>
<span id="L699"><span class="lineNum">     699</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         result.AddInput(*lowest_larger);</span></span>
<span id="L700"><span class="lineNum">     700</span>                 :<span class="tlaUNC">           0 :         return result;</span></span>
<span id="L701"><span class="lineNum">     701</span>                 :             :     }</span>
<span id="L702"><span class="lineNum">     702</span>                 :             : </span>
<span id="L703"><span class="lineNum">     703</span>                 :             :     // Solve subset sum by stochastic approximation</span>
<span id="L704"><span class="lineNum">     704</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     std::sort(applicable_groups.begin(), applicable_groups.end(), descending);</span></span>
<span id="L705"><span class="lineNum">     705</span>                 :<span class="tlaUNC">           0 :     std::vector&lt;char&gt; vfBest;</span></span>
<span id="L706"><span class="lineNum">     706</span>                 :<span class="tlaUNC">           0 :     CAmount nBest;</span></span>
<span id="L707"><span class="lineNum">     707</span>                 :             : </span>
<span id="L708"><span class="lineNum">     708</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     ApproximateBestSubset(rng, applicable_groups, nTotalLower, nTargetValue, vfBest, nBest, max_selection_weight);</span></span>
<span id="L709"><span class="lineNum">     709</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (nBest != nTargetValue &amp;&amp; nTotalLower &gt;= nTargetValue + change_target) {</span></span>
<span id="L710"><span class="lineNum">     710</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         ApproximateBestSubset(rng, applicable_groups, nTotalLower, nTargetValue + change_target, vfBest, nBest, max_selection_weight);</span></span>
<span id="L711"><span class="lineNum">     711</span>                 :             :     }</span>
<span id="L712"><span class="lineNum">     712</span>                 :             : </span>
<span id="L713"><span class="lineNum">     713</span>                 :             :     // If we have a bigger coin and (either the stochastic approximation didn't find a good solution,</span>
<span id="L714"><span class="lineNum">     714</span>                 :             :     //                                   or the next bigger coin is closer), return the bigger coin</span>
<span id="L715"><span class="lineNum">     715</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (lowest_larger &amp;&amp;</span></span>
<span id="L716"><span class="lineNum">     716</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :         ((nBest != nTargetValue &amp;&amp; nBest &lt; nTargetValue + change_target) || lowest_larger-&gt;GetSelectionAmount() &lt;= nBest)) {</span></span>
<span class="lineNum">        </span> <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span><span class="tlaUNC" title="Branch 6 was not executed"> # </span><span class="tlaUNC" title="Branch 7 was not executed"> # </span><span class="tlaUNC" title="Branch 8 was not executed"> # </span> 
<span class="lineNum">        </span>             <span class="tlaUNC" title="Branch 9 was not executed"> # </span>]
<span id="L717"><span class="lineNum">     717</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         result.AddInput(*lowest_larger);</span></span>
<span id="L718"><span class="lineNum">     718</span>                 :             :     } else {</span>
<span id="L719"><span class="lineNum">     719</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         for (unsigned int i = 0; i &lt; applicable_groups.size(); i++) {</span></span>
<span id="L720"><span class="lineNum">     720</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (vfBest[i]) {</span></span>
<span id="L721"><span class="lineNum">     721</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 result.AddInput(applicable_groups[i]);</span></span>
<span id="L722"><span class="lineNum">     722</span>                 :             :             }</span>
<span id="L723"><span class="lineNum">     723</span>                 :             :         }</span>
<span id="L724"><span class="lineNum">     724</span>                 :             : </span>
<span id="L725"><span class="lineNum">     725</span>                 :             :         // If the result exceeds the maximum allowed size, return closest UTXO above the target</span>
<span id="L726"><span class="lineNum">     726</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (result.GetWeight() &gt; max_selection_weight) {</span></span>
<span id="L727"><span class="lineNum">     727</span>                 :             :             // No coin above target, nothing to do.</span>
<span id="L728"><span class="lineNum">     728</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :             if (!lowest_larger) return ErrorMaxWeightExceeded();</span></span>
<span id="L729"><span class="lineNum">     729</span>                 :             : </span>
<span id="L730"><span class="lineNum">     730</span>                 :             :             // Return closest UTXO above target</span>
<span id="L731"><span class="lineNum">     731</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             result.Clear();</span></span>
<span id="L732"><span class="lineNum">     732</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             result.AddInput(*lowest_larger);</span></span>
<span id="L733"><span class="lineNum">     733</span>                 :             :         }</span>
<span id="L734"><span class="lineNum">     734</span>                 :             : </span>
<span id="L735"><span class="lineNum">     735</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         if (LogAcceptCategory(BCLog::SELECTCOINS, BCLog::Level::Debug)) {</span></span>
<span id="L736"><span class="lineNum">     736</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             std::string log_message{&quot;Coin selection best subset: &quot;};</span></span>
<span id="L737"><span class="lineNum">     737</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :             for (unsigned int i = 0; i &lt; applicable_groups.size(); i++) {</span></span>
<span id="L738"><span class="lineNum">     738</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                 if (vfBest[i]) {</span></span>
<span id="L739"><span class="lineNum">     739</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :                     log_message += strprintf(&quot;%s &quot;, FormatMoney(applicable_groups[i].m_value));</span></span>
<span id="L740"><span class="lineNum">     740</span>                 :             :                 }</span>
<span id="L741"><span class="lineNum">     741</span>                 :             :             }</span>
<span id="L742"><span class="lineNum">     742</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :             LogDebug(BCLog::SELECTCOINS, &quot;%stotal %s\n&quot;, log_message, FormatMoney(nBest));</span></span>
<span class="lineNum">        </span>    <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span><span class="tlaUNC" title="Branch 6 was not executed"> # </span><span class="tlaUNC" title="Branch 7 was not executed"> # </span>]
<span id="L743"><span class="lineNum">     743</span>                 :<span class="tlaUNC">           0 :         }</span></span>
<span id="L744"><span class="lineNum">     744</span>                 :             :     }</span>
<span id="L745"><span class="lineNum">     745</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     Assume(result.GetWeight() &lt;= max_selection_weight);</span></span>
<span id="L746"><span class="lineNum">     746</span>                 :<span class="tlaUNC">           0 :     return result;</span></span>
<span id="L747"><span class="lineNum">     747</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L748"><span class="lineNum">     748</span>                 :             : </span>
<span id="L749"><span class="lineNum">     749</span>                 :             : /******************************************************************************</span>
<span id="L750"><span class="lineNum">     750</span>                 :             : </span>
<span id="L751"><span class="lineNum">     751</span>                 :             :  OutputGroup</span>
<span id="L752"><span class="lineNum">     752</span>                 :             : </span>
<span id="L753"><span class="lineNum">     753</span>                 :             :  ******************************************************************************/</span>
<span id="L754"><span class="lineNum">     754</span>                 :             : </span>
<span id="L755"><span class="lineNum">     755</span>                 :<span class="tlaUNC">           0 : void OutputGroup::Insert(const std::shared_ptr&lt;COutput&gt;&amp; output, size_t ancestors, size_t descendants) {</span></span>
<span id="L756"><span class="lineNum">     756</span>                 :<span class="tlaUNC">           0 :     m_outputs.push_back(output);</span></span>
<span id="L757"><span class="lineNum">     757</span>                 :<span class="tlaUNC">           0 :     auto&amp; coin = *m_outputs.back();</span></span>
<span id="L758"><span class="lineNum">     758</span>                 :             : </span>
<span id="L759"><span class="lineNum">     759</span>                 :<span class="tlaUNC">           0 :     fee += coin.GetFee();</span></span>
<span id="L760"><span class="lineNum">     760</span>                 :             : </span>
<span id="L761"><span class="lineNum">     761</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     coin.long_term_fee = coin.input_bytes &lt; 0 ? 0 : m_long_term_feerate.GetFee(coin.input_bytes);</span></span>
<span id="L762"><span class="lineNum">     762</span>                 :<span class="tlaUNC">           0 :     long_term_fee += coin.long_term_fee;</span></span>
<span id="L763"><span class="lineNum">     763</span>                 :             : </span>
<span id="L764"><span class="lineNum">     764</span>                 :<span class="tlaUNC">           0 :     effective_value += coin.GetEffectiveValue();</span></span>
<span id="L765"><span class="lineNum">     765</span>                 :             : </span>
<span id="L766"><span class="lineNum">     766</span>                 :<span class="tlaUNC">           0 :     m_from_me &amp;= coin.from_me;</span></span>
<span id="L767"><span class="lineNum">     767</span>                 :<span class="tlaUNC">           0 :     m_value += coin.txout.nValue;</span></span>
<span id="L768"><span class="lineNum">     768</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     m_depth = std::min(m_depth, coin.depth);</span></span>
<span id="L769"><span class="lineNum">     769</span>                 :             :     // ancestors here express the number of ancestors the new coin will end up having, which is</span>
<span id="L770"><span class="lineNum">     770</span>                 :             :     // the sum, rather than the max; this will overestimate in the cases where multiple inputs</span>
<span id="L771"><span class="lineNum">     771</span>                 :             :     // have common ancestors</span>
<span id="L772"><span class="lineNum">     772</span>                 :<span class="tlaUNC">           0 :     m_ancestors += ancestors;</span></span>
<span id="L773"><span class="lineNum">     773</span>                 :             :     // descendants is the count as seen from the top ancestor, not the descendants as seen from the</span>
<span id="L774"><span class="lineNum">     774</span>                 :             :     // coin itself; thus, this value is counted as the max, not the sum</span>
<span id="L775"><span class="lineNum">     775</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     m_descendants = std::max(m_descendants, descendants);</span></span>
<span id="L776"><span class="lineNum">     776</span>                 :             : </span>
<span id="L777"><span class="lineNum">     777</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (output-&gt;input_bytes &gt; 0) {</span></span>
<span id="L778"><span class="lineNum">     778</span>                 :<span class="tlaUNC">           0 :         m_weight += output-&gt;input_bytes * WITNESS_SCALE_FACTOR;</span></span>
<span id="L779"><span class="lineNum">     779</span>                 :             :     }</span>
<span id="L780"><span class="lineNum">     780</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L781"><span class="lineNum">     781</span>                 :             : </span>
<span id="L782"><span class="lineNum">     782</span>                 :<span class="tlaUNC">           0 : bool OutputGroup::EligibleForSpending(const CoinEligibilityFilter&amp; eligibility_filter) const</span></span>
<span id="L783"><span class="lineNum">     783</span>                 :             : {</span>
<span id="L784"><span class="lineNum">     784</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     return m_depth &gt;= (m_from_me ? eligibility_filter.conf_mine : eligibility_filter.conf_theirs)</span></span>
<span id="L785"><span class="lineNum">     785</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         &amp;&amp; m_ancestors &lt;= eligibility_filter.max_ancestors</span></span>
<span id="L786"><span class="lineNum">     786</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :         &amp;&amp; m_descendants &lt;= eligibility_filter.max_descendants;</span></span>
<span id="L787"><span class="lineNum">     787</span>                 :             : }</span>
<span id="L788"><span class="lineNum">     788</span>                 :             : </span>
<span id="L789"><span class="lineNum">     789</span>                 :<span class="tlaUNC">           0 : CAmount OutputGroup::GetSelectionAmount() const</span></span>
<span id="L790"><span class="lineNum">     790</span>                 :             : {</span>
<span id="L791"><span class="lineNum">     791</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     return m_subtract_fee_outputs ? m_value : effective_value;</span></span>
<span id="L792"><span class="lineNum">     792</span>                 :             : }</span>
<span id="L793"><span class="lineNum">     793</span>                 :             : </span>
<span id="L794"><span class="lineNum">     794</span>                 :<span class="tlaUNC">           0 : void OutputGroupTypeMap::Push(const OutputGroup&amp; group, OutputType type, bool insert_positive, bool insert_mixed)</span></span>
<span id="L795"><span class="lineNum">     795</span>                 :             : {</span>
<span id="L796"><span class="lineNum">     796</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (group.m_outputs.empty()) return;</span></span>
<span id="L797"><span class="lineNum">     797</span>                 :             : </span>
<span id="L798"><span class="lineNum">     798</span>                 :<span class="tlaUNC">           0 :     Groups&amp; groups = groups_by_type[type];</span></span>
<span id="L799"><span class="lineNum">     799</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (insert_positive &amp;&amp; group.GetSelectionAmount() &gt; 0) {</span></span>
<span id="L800"><span class="lineNum">     800</span>                 :<span class="tlaUNC">           0 :         groups.positive_group.emplace_back(group);</span></span>
<span id="L801"><span class="lineNum">     801</span>                 :<span class="tlaUNC">           0 :         all_groups.positive_group.emplace_back(group);</span></span>
<span id="L802"><span class="lineNum">     802</span>                 :             :     }</span>
<span id="L803"><span class="lineNum">     803</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (insert_mixed) {</span></span>
<span id="L804"><span class="lineNum">     804</span>                 :<span class="tlaUNC">           0 :         groups.mixed_group.emplace_back(group);</span></span>
<span id="L805"><span class="lineNum">     805</span>                 :<span class="tlaUNC">           0 :         all_groups.mixed_group.emplace_back(group);</span></span>
<span id="L806"><span class="lineNum">     806</span>                 :             :     }</span>
<span id="L807"><span class="lineNum">     807</span>                 :             : }</span>
<span id="L808"><span class="lineNum">     808</span>                 :             : </span>
<span id="L809"><span class="lineNum">     809</span>                 :<span class="tlaUNC">           0 : CAmount GenerateChangeTarget(const CAmount payment_value, const CAmount change_fee, FastRandomContext&amp; rng)</span></span>
<span id="L810"><span class="lineNum">     810</span>                 :             : {</span>
<span id="L811"><span class="lineNum">     811</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (payment_value &lt;= CHANGE_LOWER / 2) {</span></span>
<span id="L812"><span class="lineNum">     812</span>                 :<span class="tlaUNC">           0 :         return change_fee + CHANGE_LOWER;</span></span>
<span id="L813"><span class="lineNum">     813</span>                 :             :     } else {</span>
<span id="L814"><span class="lineNum">     814</span>                 :             :         // random value between 50ksat and min (payment_value * 2, 1milsat)</span>
<span id="L815"><span class="lineNum">     815</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         const auto upper_bound = std::min(payment_value * 2, CHANGE_UPPER);</span></span>
<span id="L816"><span class="lineNum">     816</span>                 :<span class="tlaUNC">           0 :         return change_fee + rng.randrange(upper_bound - CHANGE_LOWER) + CHANGE_LOWER;</span></span>
<span id="L817"><span class="lineNum">     817</span>                 :             :     }</span>
<span id="L818"><span class="lineNum">     818</span>                 :             : }</span>
<span id="L819"><span class="lineNum">     819</span>                 :             : </span>
<span id="L820"><span class="lineNum">     820</span>                 :<span class="tlaUNC">           0 : void SelectionResult::SetBumpFeeDiscount(const CAmount discount)</span></span>
<span id="L821"><span class="lineNum">     821</span>                 :             : {</span>
<span id="L822"><span class="lineNum">     822</span>                 :             :     // Overlapping ancestry can only lower the fees, not increase them</span>
<span id="L823"><span class="lineNum">     823</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     assert (discount &gt;= 0);</span></span>
<span id="L824"><span class="lineNum">     824</span>                 :<span class="tlaUNC">           0 :     bump_fee_group_discount = discount;</span></span>
<span id="L825"><span class="lineNum">     825</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L826"><span class="lineNum">     826</span>                 :             : </span>
<span id="L827"><span class="lineNum">     827</span>                 :<span class="tlaUNC">           0 : void SelectionResult::RecalculateWaste(const CAmount min_viable_change, const CAmount change_cost, const CAmount change_fee)</span></span>
<span id="L828"><span class="lineNum">     828</span>                 :             : {</span>
<span id="L829"><span class="lineNum">     829</span>                 :             :     // This function should not be called with empty inputs as that would mean the selection failed</span>
<span id="L830"><span class="lineNum">     830</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     assert(!m_selected_inputs.empty());</span></span>
<span id="L831"><span class="lineNum">     831</span>                 :             : </span>
<span id="L832"><span class="lineNum">     832</span>                 :             :     // Always consider the cost of spending an input now vs in the future.</span>
<span id="L833"><span class="lineNum">     833</span>                 :<span class="tlaUNC">           0 :     CAmount waste = 0;</span></span>
<span id="L834"><span class="lineNum">     834</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     for (const auto&amp; coin_ptr : m_selected_inputs) {</span></span>
<span id="L835"><span class="lineNum">     835</span>                 :<span class="tlaUNC">           0 :         const COutput&amp; coin = *coin_ptr;</span></span>
<span id="L836"><span class="lineNum">     836</span>                 :<span class="tlaUNC">           0 :         waste += coin.GetFee() - coin.long_term_fee;</span></span>
<span id="L837"><span class="lineNum">     837</span>                 :             :     }</span>
<span id="L838"><span class="lineNum">     838</span>                 :             :     // Bump fee of whole selection may diverge from sum of individual bump fees</span>
<span id="L839"><span class="lineNum">     839</span>                 :<span class="tlaUNC">           0 :     waste -= bump_fee_group_discount;</span></span>
<span id="L840"><span class="lineNum">     840</span>                 :             : </span>
<span id="L841"><span class="lineNum">     841</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (GetChange(min_viable_change, change_fee)) {</span></span>
<span id="L842"><span class="lineNum">     842</span>                 :             :         // if we have a minimum viable amount after deducting fees, account for</span>
<span id="L843"><span class="lineNum">     843</span>                 :             :         // cost of creating and spending change</span>
<span id="L844"><span class="lineNum">     844</span>                 :<span class="tlaUNC">           0 :         waste += change_cost;</span></span>
<span id="L845"><span class="lineNum">     845</span>                 :             :     } else {</span>
<span id="L846"><span class="lineNum">     846</span>                 :             :         // When we are not making change (GetChange(…) == 0), consider the excess we are throwing away to fees</span>
<span id="L847"><span class="lineNum">     847</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         CAmount selected_effective_value = m_use_effective ? GetSelectedEffectiveValue() : GetSelectedValue();</span></span>
<span id="L848"><span class="lineNum">     848</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         assert(selected_effective_value &gt;= m_target);</span></span>
<span id="L849"><span class="lineNum">     849</span>                 :<span class="tlaUNC">           0 :         waste += selected_effective_value - m_target;</span></span>
<span id="L850"><span class="lineNum">     850</span>                 :             :     }</span>
<span id="L851"><span class="lineNum">     851</span>                 :             : </span>
<span id="L852"><span class="lineNum">     852</span>                 :<span class="tlaUNC">           0 :     m_waste = waste;</span></span>
<span id="L853"><span class="lineNum">     853</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L854"><span class="lineNum">     854</span>                 :             : </span>
<span id="L855"><span class="lineNum">     855</span>                 :<span class="tlaUNC">           0 : void SelectionResult::SetAlgoCompleted(bool algo_completed)</span></span>
<span id="L856"><span class="lineNum">     856</span>                 :             : {</span>
<span id="L857"><span class="lineNum">     857</span>                 :<span class="tlaUNC">           0 :     m_algo_completed = algo_completed;</span></span>
<span id="L858"><span class="lineNum">     858</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L859"><span class="lineNum">     859</span>                 :             : </span>
<span id="L860"><span class="lineNum">     860</span>                 :<span class="tlaUNC">           0 : bool SelectionResult::GetAlgoCompleted() const</span></span>
<span id="L861"><span class="lineNum">     861</span>                 :             : {</span>
<span id="L862"><span class="lineNum">     862</span>                 :<span class="tlaUNC">           0 :     return m_algo_completed;</span></span>
<span id="L863"><span class="lineNum">     863</span>                 :             : }</span>
<span id="L864"><span class="lineNum">     864</span>                 :             : </span>
<span id="L865"><span class="lineNum">     865</span>                 :<span class="tlaUNC">           0 : void SelectionResult::SetSelectionsEvaluated(size_t attempts)</span></span>
<span id="L866"><span class="lineNum">     866</span>                 :             : {</span>
<span id="L867"><span class="lineNum">     867</span>                 :<span class="tlaUNC">           0 :     m_selections_evaluated = attempts;</span></span>
<span id="L868"><span class="lineNum">     868</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L869"><span class="lineNum">     869</span>                 :             : </span>
<span id="L870"><span class="lineNum">     870</span>                 :<span class="tlaUNC">           0 : size_t SelectionResult::GetSelectionsEvaluated() const</span></span>
<span id="L871"><span class="lineNum">     871</span>                 :             : {</span>
<span id="L872"><span class="lineNum">     872</span>                 :<span class="tlaUNC">           0 :     return m_selections_evaluated;</span></span>
<span id="L873"><span class="lineNum">     873</span>                 :             : }</span>
<span id="L874"><span class="lineNum">     874</span>                 :             : </span>
<span id="L875"><span class="lineNum">     875</span>                 :<span class="tlaUNC">           0 : CAmount SelectionResult::GetWaste() const</span></span>
<span id="L876"><span class="lineNum">     876</span>                 :             : {</span>
<span id="L877"><span class="lineNum">     877</span>                 :<span class="tlaUNC">           0 :     return *Assert(m_waste);</span></span>
<span id="L878"><span class="lineNum">     878</span>                 :             : }</span>
<span id="L879"><span class="lineNum">     879</span>                 :             : </span>
<span id="L880"><span class="lineNum">     880</span>                 :<span class="tlaUNC">           0 : CAmount SelectionResult::GetSelectedValue() const</span></span>
<span id="L881"><span class="lineNum">     881</span>                 :             : {</span>
<span id="L882"><span class="lineNum">     882</span>                 :<span class="tlaUNC">           0 :     return std::accumulate(m_selected_inputs.cbegin(), m_selected_inputs.cend(), CAmount{0}, [](CAmount sum, const auto&amp; coin) { return sum + coin-&gt;txout.nValue; });</span></span>
<span id="L883"><span class="lineNum">     883</span>                 :             : }</span>
<span id="L884"><span class="lineNum">     884</span>                 :             : </span>
<span id="L885"><span class="lineNum">     885</span>                 :<span class="tlaUNC">           0 : CAmount SelectionResult::GetSelectedEffectiveValue() const</span></span>
<span id="L886"><span class="lineNum">     886</span>                 :             : {</span>
<span id="L887"><span class="lineNum">     887</span>                 :<span class="tlaUNC">           0 :     return std::accumulate(m_selected_inputs.cbegin(), m_selected_inputs.cend(), CAmount{0}, [](CAmount sum, const auto&amp; coin) { return sum + coin-&gt;GetEffectiveValue(); }) + bump_fee_group_discount;</span></span>
<span id="L888"><span class="lineNum">     888</span>                 :             : }</span>
<span id="L889"><span class="lineNum">     889</span>                 :             : </span>
<span id="L890"><span class="lineNum">     890</span>                 :<span class="tlaUNC">           0 : CAmount SelectionResult::GetTotalBumpFees() const</span></span>
<span id="L891"><span class="lineNum">     891</span>                 :             : {</span>
<span id="L892"><span class="lineNum">     892</span>                 :<span class="tlaUNC">           0 :     return std::accumulate(m_selected_inputs.cbegin(), m_selected_inputs.cend(), CAmount{0}, [](CAmount sum, const auto&amp; coin) { return sum + coin-&gt;ancestor_bump_fees; }) - bump_fee_group_discount;</span></span>
<span id="L893"><span class="lineNum">     893</span>                 :             : }</span>
<span id="L894"><span class="lineNum">     894</span>                 :             : </span>
<span id="L895"><span class="lineNum">     895</span>                 :<span class="tlaUNC">           0 : void SelectionResult::Clear()</span></span>
<span id="L896"><span class="lineNum">     896</span>                 :             : {</span>
<span id="L897"><span class="lineNum">     897</span>                 :<span class="tlaUNC">           0 :     m_selected_inputs.clear();</span></span>
<span id="L898"><span class="lineNum">     898</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     m_waste.reset();</span></span>
<span id="L899"><span class="lineNum">     899</span>                 :<span class="tlaUNC">           0 :     m_weight = 0;</span></span>
<span id="L900"><span class="lineNum">     900</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L901"><span class="lineNum">     901</span>                 :             : </span>
<span id="L902"><span class="lineNum">     902</span>                 :<span class="tlaUNC">           0 : void SelectionResult::AddInput(const OutputGroup&amp; group)</span></span>
<span id="L903"><span class="lineNum">     903</span>                 :             : {</span>
<span id="L904"><span class="lineNum">     904</span>                 :             :     // As it can fail, combine inputs first</span>
<span id="L905"><span class="lineNum">     905</span>                 :<span class="tlaUNC">           0 :     InsertInputs(group.m_outputs);</span></span>
<span id="L906"><span class="lineNum">     906</span>                 :<span class="tlaUNC">           0 :     m_use_effective = !group.m_subtract_fee_outputs;</span></span>
<span id="L907"><span class="lineNum">     907</span>                 :             : </span>
<span id="L908"><span class="lineNum">     908</span>                 :<span class="tlaUNC">           0 :     m_weight += group.m_weight;</span></span>
<span id="L909"><span class="lineNum">     909</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L910"><span class="lineNum">     910</span>                 :             : </span>
<span id="L911"><span class="lineNum">     911</span>                 :<span class="tlaUNC">           0 : void SelectionResult::AddInputs(const std::set&lt;std::shared_ptr&lt;COutput&gt;&gt;&amp; inputs, bool subtract_fee_outputs)</span></span>
<span id="L912"><span class="lineNum">     912</span>                 :             : {</span>
<span id="L913"><span class="lineNum">     913</span>                 :             :     // As it can fail, combine inputs first</span>
<span id="L914"><span class="lineNum">     914</span>                 :<span class="tlaUNC">           0 :     InsertInputs(inputs);</span></span>
<span id="L915"><span class="lineNum">     915</span>                 :<span class="tlaUNC">           0 :     m_use_effective = !subtract_fee_outputs;</span></span>
<span id="L916"><span class="lineNum">     916</span>                 :             : </span>
<span id="L917"><span class="lineNum">     917</span>                 :<span class="tlaUNC">           0 :     m_weight += std::accumulate(inputs.cbegin(), inputs.cend(), 0, [](int sum, const auto&amp; coin) {</span></span>
<span id="L918"><span class="lineNum">     918</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :         return sum + std::max(coin-&gt;input_bytes, 0) * WITNESS_SCALE_FACTOR;</span></span>
<span id="L919"><span class="lineNum">     919</span>                 :             :     });</span>
<span id="L920"><span class="lineNum">     920</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L921"><span class="lineNum">     921</span>                 :             : </span>
<span id="L922"><span class="lineNum">     922</span>                 :<span class="tlaUNC">           0 : void SelectionResult::Merge(const SelectionResult&amp; other)</span></span>
<span id="L923"><span class="lineNum">     923</span>                 :             : {</span>
<span id="L924"><span class="lineNum">     924</span>                 :             :     // As it can fail, combine inputs first</span>
<span id="L925"><span class="lineNum">     925</span>                 :<span class="tlaUNC">           0 :     InsertInputs(other.m_selected_inputs);</span></span>
<span id="L926"><span class="lineNum">     926</span>                 :             : </span>
<span id="L927"><span class="lineNum">     927</span>                 :<span class="tlaUNC">           0 :     m_target += other.m_target;</span></span>
<span id="L928"><span class="lineNum">     928</span>                 :<span class="tlaUNC">           0 :     m_use_effective |= other.m_use_effective;</span></span>
<span id="L929"><span class="lineNum">     929</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (m_algo == SelectionAlgorithm::MANUAL) {</span></span>
<span id="L930"><span class="lineNum">     930</span>                 :<span class="tlaUNC">           0 :         m_algo = other.m_algo;</span></span>
<span id="L931"><span class="lineNum">     931</span>                 :             :     }</span>
<span id="L932"><span class="lineNum">     932</span>                 :             : </span>
<span id="L933"><span class="lineNum">     933</span>                 :<span class="tlaUNC">           0 :     m_weight += other.m_weight;</span></span>
<span id="L934"><span class="lineNum">     934</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L935"><span class="lineNum">     935</span>                 :             : </span>
<span id="L936"><span class="lineNum">     936</span>                 :<span class="tlaUNC">           0 : const std::set&lt;std::shared_ptr&lt;COutput&gt;&gt;&amp; SelectionResult::GetInputSet() const</span></span>
<span id="L937"><span class="lineNum">     937</span>                 :             : {</span>
<span id="L938"><span class="lineNum">     938</span>                 :<span class="tlaUNC">           0 :     return m_selected_inputs;</span></span>
<span id="L939"><span class="lineNum">     939</span>                 :             : }</span>
<span id="L940"><span class="lineNum">     940</span>                 :             : </span>
<span id="L941"><span class="lineNum">     941</span>                 :<span class="tlaUNC">           0 : std::vector&lt;std::shared_ptr&lt;COutput&gt;&gt; SelectionResult::GetShuffledInputVector() const</span></span>
<span id="L942"><span class="lineNum">     942</span>                 :             : {</span>
<span id="L943"><span class="lineNum">     943</span>                 :<span class="tlaUNC">           0 :     std::vector&lt;std::shared_ptr&lt;COutput&gt;&gt; coins(m_selected_inputs.begin(), m_selected_inputs.end());</span></span>
<span id="L944"><span class="lineNum">     944</span>                 :<span class="tlaUNC">           0 :     std::shuffle(coins.begin(), coins.end(), FastRandomContext());</span></span>
<span id="L945"><span class="lineNum">     945</span>                 :<span class="tlaUNC">           0 :     return coins;</span></span>
<span id="L946"><span class="lineNum">     946</span>                 :             : }</span>
<span id="L947"><span class="lineNum">     947</span>                 :             : </span>
<span id="L948"><span class="lineNum">     948</span>                 :<span class="tlaUNC">           0 : bool SelectionResult::operator&lt;(SelectionResult other) const</span></span>
<span id="L949"><span class="lineNum">     949</span>                 :             : {</span>
<span id="L950"><span class="lineNum">     950</span>                 :<span class="tlaUNC">           0 :     Assert(m_waste.has_value());</span></span>
<span id="L951"><span class="lineNum">     951</span>                 :<span class="tlaUNC">           0 :     Assert(other.m_waste.has_value());</span></span>
<span id="L952"><span class="lineNum">     952</span>                 :             :     // As this operator is only used in std::min_element, we want the result that has more inputs when waste are equal.</span>
<span id="L953"><span class="lineNum">     953</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :     return *m_waste &lt; *other.m_waste || (*m_waste == *other.m_waste &amp;&amp; m_selected_inputs.size() &gt; other.m_selected_inputs.size());</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L954"><span class="lineNum">     954</span>                 :             : }</span>
<span id="L955"><span class="lineNum">     955</span>                 :             : </span>
<span id="L956"><span class="lineNum">     956</span>                 :<span class="tlaUNC">           0 : std::string COutput::ToString() const</span></span>
<span id="L957"><span class="lineNum">     957</span>                 :             : {</span>
<span id="L958"><span class="lineNum">     958</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span>]:<span class="tlaUNC">           0 :     return strprintf(&quot;COutput(%s, %d, %d) [%s]&quot;, outpoint.hash.ToString(), outpoint.n, depth, FormatMoney(txout.nValue));</span></span>
<span id="L959"><span class="lineNum">     959</span>                 :             : }</span>
<span id="L960"><span class="lineNum">     960</span>                 :             : </span>
<span id="L961"><span class="lineNum">     961</span>                 :<span class="tlaUNC">           0 : std::string GetAlgorithmName(const SelectionAlgorithm algo)</span></span>
<span id="L962"><span class="lineNum">     962</span>                 :             : {</span>
<span id="L963"><span class="lineNum">     963</span>   [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span><span class="tlaUNC" title="Branch 2 was not executed"> # </span><span class="tlaUNC" title="Branch 3 was not executed"> # </span> :<span class="tlaUNC">           0 :     switch (algo)</span></span>
<span class="lineNum">        </span>          <span class="tlaUNC" title="Branch 4 was not executed"> # </span><span class="tlaUNC" title="Branch 5 was not executed"> # </span>]
<span id="L964"><span class="lineNum">     964</span>                 :             :     {</span>
<span id="L965"><span class="lineNum">     965</span>                 :<span class="tlaUNC">           0 :     case SelectionAlgorithm::BNB: return &quot;bnb&quot;;</span></span>
<span id="L966"><span class="lineNum">     966</span>                 :<span class="tlaUNC">           0 :     case SelectionAlgorithm::KNAPSACK: return &quot;knapsack&quot;;</span></span>
<span id="L967"><span class="lineNum">     967</span>                 :<span class="tlaUNC">           0 :     case SelectionAlgorithm::SRD: return &quot;srd&quot;;</span></span>
<span id="L968"><span class="lineNum">     968</span>                 :<span class="tlaUNC">           0 :     case SelectionAlgorithm::CG: return &quot;cg&quot;;</span></span>
<span id="L969"><span class="lineNum">     969</span>                 :<span class="tlaUNC">           0 :     case SelectionAlgorithm::MANUAL: return &quot;manual&quot;;</span></span>
<span id="L970"><span class="lineNum">     970</span>                 :             :     // No default case to allow for compiler to warn</span>
<span id="L971"><span class="lineNum">     971</span>                 :             :     }</span>
<span id="L972"><span class="lineNum">     972</span>                 :<span class="tlaUNC">           0 :     assert(false);</span></span>
<span id="L973"><span class="lineNum">     973</span>                 :             : }</span>
<span id="L974"><span class="lineNum">     974</span>                 :             : </span>
<span id="L975"><span class="lineNum">     975</span>                 :<span class="tlaUNC">           0 : CAmount SelectionResult::GetChange(const CAmount min_viable_change, const CAmount change_fee) const</span></span>
<span id="L976"><span class="lineNum">     976</span>                 :             : {</span>
<span id="L977"><span class="lineNum">     977</span>                 :             :     // change = SUM(inputs) - SUM(outputs) - fees</span>
<span id="L978"><span class="lineNum">     978</span>                 :             :     // 1) With SFFO we don't pay any fees</span>
<span id="L979"><span class="lineNum">     979</span>                 :             :     // 2) Otherwise we pay all the fees:</span>
<span id="L980"><span class="lineNum">     980</span>                 :             :     //  - input fees are covered by GetSelectedEffectiveValue()</span>
<span id="L981"><span class="lineNum">     981</span>                 :             :     //  - non_input_fee is included in m_target</span>
<span id="L982"><span class="lineNum">     982</span>                 :             :     //  - change_fee</span>
<span id="L983"><span class="lineNum">     983</span>                 :<span class="tlaUNC">           0 :     const CAmount change = m_use_effective</span></span>
<span id="L984"><span class="lineNum">     984</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :                            ? GetSelectedEffectiveValue() - m_target - change_fee</span></span>
<span id="L985"><span class="lineNum">     985</span>                 :<span class="tlaUNC">           0 :                            : GetSelectedValue() - m_target;</span></span>
<span id="L986"><span class="lineNum">     986</span>                 :             : </span>
<span id="L987"><span class="lineNum">     987</span>         [<span class="tlaUNC" title="Branch 0 was not executed"> # </span><span class="tlaUNC" title="Branch 1 was not executed"> # </span>]:<span class="tlaUNC">           0 :     if (change &lt; min_viable_change) {</span></span>
<span id="L988"><span class="lineNum">     988</span>                 :<span class="tlaUNC">           0 :         return 0;</span></span>
<span id="L989"><span class="lineNum">     989</span>                 :             :     }</span>
<span id="L990"><span class="lineNum">     990</span>                 :             : </span>
<span id="L991"><span class="lineNum">     991</span>                 :             :     return change;</span>
<span id="L992"><span class="lineNum">     992</span>                 :             : }</span>
<span id="L993"><span class="lineNum">     993</span>                 :             : </span>
<span id="L994"><span class="lineNum">     994</span>                 :             : } // namespace wallet</span>
        </pre>
              </td>
            </tr>
          </table>
          <br>

          <table width="100%" border=0 cellspacing=0 cellpadding=0>
            <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
            <tr><td class="versionInfo">Generated by: <a href="https://github.com//linux-test-project/lcov" target="_parent">LCOV version 2.0-1</a></td></tr>
          </table>
          <br>

</body>
</html>
